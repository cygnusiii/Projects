package vpx;
import java.util.Collections;
import java.util.Iterator;
import org.bridj.BridJ;
import org.bridj.CRuntime;
import org.bridj.Callback;
import org.bridj.FlagSet;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.TypedPointer;
import org.bridj.ann.CLong;
import org.bridj.ann.Library;
import org.bridj.ann.Name;
import org.bridj.ann.Ptr;
import org.bridj.ann.Runtime;
/**
 * Wrapper for library <b>vpx</b><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("vpx") 
@Runtime(CRuntime.class) 
public class VpxLibrary {
	static {
		BridJ.register();
	}
	/**
	 * enum values<br>
	 * <i>native declaration : vpx\vpx_image.h</i>
	 */
	public enum vpx_img_fmt_t implements IntValuedEnum<vpx_img_fmt_t > {
		VPX_IMG_FMT_NONE(0),
		/// < 24 bit per pixel packed RGB
		VPX_IMG_FMT_RGB24(1),
		/// < 32 bit per pixel packed 0RGB
		VPX_IMG_FMT_RGB32(2),
		/// < 16 bit per pixel, 565
		VPX_IMG_FMT_RGB565(3),
		/// < 16 bit per pixel, 555
		VPX_IMG_FMT_RGB555(4),
		/// < UYVY packed YUV
		VPX_IMG_FMT_UYVY(5),
		/// < YUYV packed YUV
		VPX_IMG_FMT_YUY2(6),
		/// < YVYU packed YUV
		VPX_IMG_FMT_YVYU(7),
		/// < 24 bit per pixel packed BGR
		VPX_IMG_FMT_BGR24(8),
		/// < 32 bit packed BGR0
		VPX_IMG_FMT_RGB32_LE(9),
		/// < 32 bit packed ARGB, alpha=255
		VPX_IMG_FMT_ARGB(10),
		/// < 32 bit packed BGRA, alpha=255
		VPX_IMG_FMT_ARGB_LE(11),
		/// < 16 bit per pixel, gggbbbbb rrrrrggg
		VPX_IMG_FMT_RGB565_LE(12),
		/// < 16 bit per pixel, gggbbbbb 0rrrrrgg
		VPX_IMG_FMT_RGB555_LE(13),
		/// < planar YVU
		VPX_IMG_FMT_YV12(256 | 512 | 1),
		VPX_IMG_FMT_I420(256 | 2),
		/// < planar 4:2:0 format with vpx color space
		VPX_IMG_FMT_VPXYV12(256 | 512 | 3),
		/// < planar 4:2:0 format with vpx color space
		VPX_IMG_FMT_VPXI420(256 | 4);
		vpx_img_fmt_t(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<vpx_img_fmt_t > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<vpx_img_fmt_t > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * enum values<br>
	 * <i>native declaration : vpx\vpx_codec.h</i>
	 */
	public enum vpx_codec_err_t implements IntValuedEnum<vpx_codec_err_t > {
		/// \brief Operation completed without error
		VPX_CODEC_OK(0),
		/// \brief Unspecified error
		VPX_CODEC_ERROR(1),
		/// \brief Memory operation failed
		VPX_CODEC_MEM_ERROR(2),
		/// \brief ABI version mismatch
		VPX_CODEC_ABI_MISMATCH(3),
		/// \brief Algorithm does not have required capability
		VPX_CODEC_INCAPABLE(4),
		/**
		 * \brief The given bitstream is not supported.<br>
		 * * The bitstream was unable to be parsed at the highest level. The decoder<br>
		 * is unable to proceed. This error \ref SHOULD be treated as fatal to the<br>
		 * stream.
		 */
		VPX_CODEC_UNSUP_BITSTREAM(5),
		/**
		 * \brief Encoded bitstream uses an unsupported feature<br>
		 * * The decoder does not implement a feature required by the encoder. This<br>
		 * return code should only be used for features that prevent future<br>
		 * pictures from being properly decoded. This error \ref MAY be treated as<br>
		 * fatal to the stream or \ref MAY be treated as fatal to the current GOP.
		 */
		VPX_CODEC_UNSUP_FEATURE(6),
		/**
		 * \brief The coded data for this stream is corrupt or incomplete<br>
		 * * There was a problem decoding the current frame.  This return code<br>
		 * should only be used for failures that prevent future pictures from<br>
		 * being properly decoded. This error \ref MAY be treated as fatal to the<br>
		 * stream or \ref MAY be treated as fatal to the current GOP. If decoding<br>
		 * is continued for the current GOP, artifacts may be present.
		 */
		VPX_CODEC_CORRUPT_FRAME(7),
		/// \brief An application-supplied parameter is not valid.
		VPX_CODEC_INVALID_PARAM(8),
		/// \brief An iterator reached the end of list.
		VPX_CODEC_LIST_END(9);
		vpx_codec_err_t(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<vpx_codec_err_t > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<vpx_codec_err_t > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * \brief Encoder output packet variants<br>
	 * * This enumeration lists the different kinds of data packets that can be<br>
	 * returned by calls to vpx_codec_get_cx_data(). Algorithms \ref MAY<br>
	 * extend this list to provide additional functionality.<br>
	 * enum values<br>
	 * <i>native declaration : vpx\vpx_encoder.h:137</i>
	 */
	public enum vpx_codec_cx_pkt_kind implements IntValuedEnum<vpx_codec_cx_pkt_kind > {
		/// < Compressed video frame
		VPX_CODEC_CX_FRAME_PKT(0),
		/// < Two-pass statistics for this frame
		VPX_CODEC_STATS_PKT(1),
		/// < PSNR statistics for this frame
		VPX_CODEC_PSNR_PKT(2),
		/// < Algorithm extensions
		VPX_CODEC_CUSTOM_PKT(256);
		vpx_codec_cx_pkt_kind(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<vpx_codec_cx_pkt_kind > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<vpx_codec_cx_pkt_kind > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * \brief Multi-pass Encoding Pass<br>
	 * enum values<br>
	 * <i>native declaration : vpx\vpx_encoder.h:204</i>
	 */
	public enum vpx_enc_pass implements IntValuedEnum<vpx_enc_pass > {
		/// < Single pass mode
		VPX_RC_ONE_PASS(0),
		/// < First pass of multi-pass mode
		VPX_RC_FIRST_PASS(1),
		/// < Final pass of multi-pass mode
		VPX_RC_LAST_PASS(2);
		vpx_enc_pass(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<vpx_enc_pass > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<vpx_enc_pass > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * \brief Rate control mode<br>
	 * enum values<br>
	 * <i>native declaration : vpx\vpx_encoder.h:213</i>
	 */
	public enum vpx_rc_mode implements IntValuedEnum<vpx_rc_mode > {
		/// < Variable Bit Rate (VBR) mode
		VPX_VBR(0),
		/// < Constant Bit Rate (CBR) mode
		VPX_CBR(1),
		/// < Constant Quality  (CQ)  mode
		VPX_CQ(2);
		vpx_rc_mode(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<vpx_rc_mode > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<vpx_rc_mode > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * \brief Keyframe placement mode.<br>
	 * * This enumeration determines whether keyframes are placed automatically by<br>
	 * the encoder or whether this behavior is disabled. Older releases of this<br>
	 * SDK were implemented such that VPX_KF_FIXED meant keyframes were disabled.<br>
	 * This name is confusing for this behavior, so the new symbols to be used<br>
	 * are VPX_KF_AUTO and VPX_KF_DISABLED.<br>
	 * enum values<br>
	 * <i>native declaration : vpx\vpx_encoder.h:229</i>
	 */
	public enum vpx_kf_mode implements IntValuedEnum<vpx_kf_mode > {
		/// < deprecated, implies VPX_KF_DISABLED
		VPX_KF_FIXED(0),
		/// < Encoder determines optimal placement automatically
		VPX_KF_AUTO(1),
		/// < Encoder does not place keyframes.
		VPX_KF_DISABLED(0);
		vpx_kf_mode(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<vpx_kf_mode > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<vpx_kf_mode > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * \brief Control functions<br>
	 * * The set of macros define the control functions of VP8 interface<br>
	 * enum values<br>
	 * <i>native declaration : vpx\vp8.h:38</i>
	 */
	public enum vp8_com_control_id implements IntValuedEnum<vp8_com_control_id > {
		/// < pass in an external frame into decoder to be used as reference frame
		VP8_SET_REFERENCE(1),
		/// < get a copy of reference frame from the decoder
		VP8_COPY_REFERENCE(2),
		/// < set the decoder's post processing settings
		VP8_SET_POSTPROC(3),
		/// < set the reference frames to color for each macroblock
		VP8_SET_DBG_COLOR_REF_FRAME(4),
		/// < set which macro block modes to color
		VP8_SET_DBG_COLOR_MB_MODES(5),
		/// < set which blocks modes to color
		VP8_SET_DBG_COLOR_B_MODES(6),
		/// < set which motion vector modes to draw
		VP8_SET_DBG_DISPLAY_MV(7),
		VP8_COMMON_CTRL_ID_MAX(8),
		VP8_DECODER_CTRL_ID_START(256);
		vp8_com_control_id(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<vp8_com_control_id > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<vp8_com_control_id > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * \brief post process flags<br>
	 * * The set of macros define VP8 decoder post processing flags<br>
	 * enum values<br>
	 * <i>native declaration : vpx\vp8.h:55</i>
	 */
	public enum vp8_postproc_level implements IntValuedEnum<vp8_postproc_level > {
		VP8_NOFILTERING(0),
		VP8_DEBLOCK(1 << 0),
		VP8_DEMACROBLOCK(1 << 1),
		VP8_ADDNOISE(1 << 2),
		/// < print frame information
		VP8_DEBUG_TXT_FRAME_INFO(1 << 3),
		/// < print macro block modes over each macro block
		VP8_DEBUG_TXT_MBLK_MODES(1 << 4),
		/// < print dc diff for each macro block
		VP8_DEBUG_TXT_DC_DIFF(1 << 5),
		/// < print video rate info (encoder only)
		VP8_DEBUG_TXT_RATE_INFO(1 << 6),
		VP8_MFQE(1 << 10);
		vp8_postproc_level(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<vp8_postproc_level > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<vp8_postproc_level > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * enum values<br>
	 * <i>native declaration : vpx\vp8.h</i>
	 */
	public enum vpx_ref_frame_type_t implements IntValuedEnum<vpx_ref_frame_type_t > {
		VP8_LAST_FRAME(1),
		VP8_GOLD_FRAME(2),
		VP8_ALTR_FRAME(4);
		vpx_ref_frame_type_t(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<vpx_ref_frame_type_t > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<vpx_ref_frame_type_t > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * \brief VP8 encoder control functions<br>
	 * * This set of macros define the control functions available for the VP8<br>
	 * encoder interface.<br>
	 * * \sa #vpx_codec_control<br>
	 * enum values<br>
	 * <i>native declaration : vpx\vp8cx.h:122</i>
	 */
	public enum vp8e_enc_control_id implements IntValuedEnum<vp8e_enc_control_id > {
		/// < control function to set mode of entropy update in encoder
		VP8E_UPD_ENTROPY(5),
		/// < control function to set reference update mode in encoder
		VP8E_UPD_REFERENCE(6),
		/// < control function to set which reference frame encoder can use
		VP8E_USE_REFERENCE(7),
		/// < control function to pass an ROI map to encoder
		VP8E_SET_ROI_MAP(8),
		/// < control function to pass an Active map to encoder
		VP8E_SET_ACTIVEMAP(9),
		/// < control function to set encoder scaling mode
		VP8E_SET_SCALEMODE(11),
		/**
		 * \brief control function to set vp8 encoder cpuused<br>
		 * * Changes in this value influences, among others, the encoder's selection<br>
		 * of motion estimation methods. Values greater than 0 will increase encoder<br>
		 * speed at the expense of quality.<br>
		 * The full set of adjustments can be found in<br>
		 * onyx_if.c:vp8_set_speed_features().<br>
		 * \todo List highlights of the changes at various levels.<br>
		 * * \note Valid range: -16..16
		 */
		VP8E_SET_CPUUSED(13),
		/// < control function to enable vp8 to automatic set and use altref frame
		VP8E_SET_ENABLEAUTOALTREF(14),
		/// < control function to set noise sensitivity
		VP8E_SET_NOISE_SENSITIVITY(15),
		/// < control function to set sharpness
		VP8E_SET_SHARPNESS(16),
		/// < control function to set the threshold for macroblocks treated static
		VP8E_SET_STATIC_THRESHOLD(17),
		/// < control function to set the number of token partitions
		VP8E_SET_TOKEN_PARTITIONS(18),
		/**
		 * < return the quantizer chosen by the<br>
		 * encoder for the last frame using the internal<br>
		 * scale
		 */
		VP8E_GET_LAST_QUANTIZER(19),
		/**
		 * < return the quantizer chosen by the<br>
		 * encoder for the last frame, using the 0..63<br>
		 * scale as used by the rc_*_quantizer config<br>
		 * parameters
		 */
		VP8E_GET_LAST_QUANTIZER_64(20),
		/// < control function to set the max number of frames blurred creating arf
		VP8E_SET_ARNR_MAXFRAMES(21),
		/// < control function to set the filter strength for the arf
		VP8E_SET_ARNR_STRENGTH(22),
		/// < control function to set the type of filter to use for the arf
		VP8E_SET_ARNR_TYPE(23),
		/// < control function to set visual tuning
		VP8E_SET_TUNING(24),
		/**
		 * \brief control function to set constrained quality level<br>
		 * * \attention For this value to be used vpx_codec_enc_cfg_t::g_usage must be<br>
		 *            set to #VPX_CQ.<br>
		 * \note Valid range: 0..63
		 */
		VP8E_SET_CQ_LEVEL(25),
		/**
		 * \brief Max data rate for Intra frames<br>
		 * * This value controls additional clamping on the maximum size of a<br>
		 * keyframe. It is expressed as a percentage of the average<br>
		 * per-frame bitrate, with the special (and default) value 0 meaning<br>
		 * unlimited, or no additional clamping beyond the codec's built-in<br>
		 * algorithm.<br>
		 * * For example, to allocate no more than 4.5 frames worth of bitrate<br>
		 * to a keyframe, set this to 450.
		 */
		VP8E_SET_MAX_INTRA_BITRATE_PCT(26);
		vp8e_enc_control_id(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<vp8e_enc_control_id > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<vp8e_enc_control_id > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * enum values<br>
	 * <i>native declaration : vpx\vp8cx.h</i>
	 */
	public enum VPX_SCALING_MODE implements IntValuedEnum<VPX_SCALING_MODE > {
		VP8E_NORMAL(0),
		VP8E_FOURFIVE(1),
		VP8E_THREEFIVE(2),
		VP8E_ONETWO(3);
		VPX_SCALING_MODE(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<VPX_SCALING_MODE > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<VPX_SCALING_MODE > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * enum values<br>
	 * <i>native declaration : vpx\vp8cx.h</i>
	 */
	public enum vp8e_token_partitions implements IntValuedEnum<vp8e_token_partitions > {
		VP8_ONE_TOKENPARTITION(0),
		VP8_TWO_TOKENPARTITION(1),
		VP8_FOUR_TOKENPARTITION(2),
		VP8_EIGHT_TOKENPARTITION(3);
		vp8e_token_partitions(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<vp8e_token_partitions > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<vp8e_token_partitions > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * enum values<br>
	 * <i>native declaration : vpx\vp8cx.h</i>
	 */
	public enum vp8e_tuning implements IntValuedEnum<vp8e_tuning > {
		VP8_TUNE_PSNR(0),
		VP8_TUNE_SSIM(1);
		vp8e_tuning(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<vp8e_tuning > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<vp8e_tuning > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/**
	 * \brief VP8 decoder control functions<br>
	 * * This set of macros define the control functions available for the VP8<br>
	 * decoder interface.<br>
	 * * \sa #vpx_codec_control<br>
	 * enum values<br>
	 * <i>native declaration : vpx\vp8dx.h:45</i>
	 */
	public enum vp8_dec_control_id implements IntValuedEnum<vp8_dec_control_id > {
		/**
		 * control function to get info on which reference frames were updated<br>
		 *  by the last decode
		 */
		VP8D_GET_LAST_REF_UPDATES((int)VpxLibrary.vp8_com_control_id.VP8_DECODER_CTRL_ID_START.value()),
		/// check if the indicated frame is corrupted
		VP8D_GET_FRAME_CORRUPTED((int)VpxLibrary.vp8_com_control_id.VP8_DECODER_CTRL_ID_START.value() + 1),
		/**
		 * control function to get info on which reference frames were used<br>
		 *  by the last decode
		 */
		VP8D_GET_LAST_REF_USED((int)VpxLibrary.vp8_com_control_id.VP8_DECODER_CTRL_ID_START.value() + 2),
		VP8_DECODER_CTRL_ID_MAX((int)VpxLibrary.vp8_com_control_id.VP8_DECODER_CTRL_ID_START.value() + 3);
		vp8_dec_control_id(long value) {
			this.value = value;
		}
		public final long value;
		public long value() {
			return this.value;
		}
		public Iterator<vp8_dec_control_id > iterator() {
			return Collections.singleton(this).iterator();
		}
		public static IntValuedEnum<vp8_dec_control_id > fromValue(int value) {
			return FlagSet.fromValue(value, values());
		}
	};
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_CODEC_USE_PSNR = (int)65536;
	/// <i>native declaration : vpx\vpx_codec.h</i>
	public static final int VPX_CODEC_MEM_FAST = (int)4;
	/// <i>native declaration : vpx\vp8cx.h</i>
	public static final int VP8_EFLAG_FORCE_GF = (int)(1 << 19);
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_ERROR_RESILIENT_DEFAULT = (int)1;
	/// <i>native declaration : vpx\vpx_codec.h</i>
	public static final int VPX_CODEC_USE_XMA = (int)1;
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_FRAME_IS_DROPPABLE = (int)2;
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_CODEC_CAP_OUTPUT_PARTITION = (int)131072;
	/// <i>native declaration : vpx\vp8cx.h</i>
	public static final int VP8_EFLAG_NO_UPD_ENTROPY = (int)(1 << 20);
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int VPX_PLANE_ALPHA = (int)3;
	/// <i>native declaration : vpx\vpx_decoder.h</i>
	public static final int VPX_CODEC_CAP_INPUT_FRAGMENTS = (int)1048576;
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int IMG_FMT_UV_FLIP = (int)512;
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_ERROR_RESILIENT_PARTITIONS = (int)2;
	/// <i>native declaration : vpx\vpx_codec.h</i>
	public static final int VPX_CODEC_CAP_DECODER = (int)1;
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_DL_GOOD_QUALITY = (int)(1000000);
	/// <i>native declaration : vpx\vp8cx.h</i>
	public static final int VP8_EFLAG_NO_UPD_LAST = (int)(1 << 18);
	/// <i>native declaration : vpx\vpx_decoder.h</i>
	public static final int VPX_CODEC_USE_ERROR_CONCEALMENT = (int)131072;
	/// <i>native declaration : vpx\vpx_decoder.h</i>
	public static final int VPX_CODEC_CAP_POSTPROC = (int)262144;
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int IMG_FMT_PLANAR = (int)256;
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_TS_MAX_LAYERS = (int)5;
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int VPX_IMG_FMT_PLANAR = (int)256;
	/// <i>native declaration : vpx\vp8cx.h</i>
	public static final int VP8_EFLAG_NO_REF_GF = (int)(1 << 17);
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_CODEC_CAP_PSNR = (int)65536;
	/// <i>native declaration : vpx\vp8cx.h</i>
	public static final int VP8_EFLAG_NO_REF_ARF = (int)(1 << 21);
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int VPX_PLANE_PACKED = (int)0;
	/// <i>native declaration : vpx\vpx_codec.h</i>
	public static final int VPX_CODEC_CAP_XMA = (int)4;
	/// <i>native declaration : vpx\vp8cx.h</i>
	public static final int VP8_EFLAG_NO_UPD_GF = (int)(1 << 22);
	/// <i>native declaration : vpx\vp8cx.h</i>
	public static final int VP8_EFLAG_NO_UPD_ARF = (int)(1 << 23);
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int MAX_PERIODICITY = (int)16;
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_CODEC_USE_OUTPUT_PARTITION = (int)131072;
	/// <i>native declaration : vpx\vpx_codec.h</i>
	public static final int VPX_CODEC_CAP_ENCODER = (int)2;
	/// <i>native declaration : vpx\vpx_codec.h</i>
	public static final int VPX_CODEC_ABI_VERSION = (int)(2 + (1));
	/// <i>native declaration : vpx\vp8cx.h</i>
	public static final int VP8_EFLAG_NO_REF_LAST = (int)(1 << 16);
	/// <i>native declaration : vpx\vpx_decoder.h</i>
	public static final int VPX_CODEC_CAP_PUT_SLICE = (int)65536;
	/// <i>native declaration : vpx\vpx_decoder.h</i>
	public static final int VPX_CODEC_USE_INPUT_FRAGMENTS = (int)262144;
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_DL_BEST_QUALITY = (int)(0);
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int MAX_LAYERS = (int)5;
	/// <i>native declaration : vpx\vpx_codec.h</i>
	public static final int VPX_CODEC_MEM_WRONLY = (int)2;
	/// <i>native declaration : vpx\vpx_decoder.h</i>
	public static final int VPX_CODEC_CAP_PUT_FRAME = (int)131072;
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_FRAME_IS_FRAGMENT = (int)8;
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_TS_MAX_PERIODICITY = (int)16;
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_FRAME_IS_INVISIBLE = (int)4;
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int VPX_IMAGE_ABI_VERSION = (int)(1);
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int VPX_PLANE_Y = (int)0;
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int VPX_PLANE_V = (int)2;
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int PLANE_ALPHA = (int)3;
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int VPX_PLANE_U = (int)1;
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_FRAME_IS_KEY = (int)1;
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_DL_REALTIME = (int)(1);
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int VPX_IMG_FMT_UV_FLIP = (int)512;
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_EFLAG_FORCE_KF = (int)(1 << 0);
	/// <i>native declaration : vpx\vp8cx.h</i>
	public static final int VP8_EFLAG_FORCE_ARF = (int)(1 << 24);
	/// <i>native declaration : vpx\vpx_encoder.h</i>
	public static final int VPX_ENCODER_ABI_VERSION = (int)(3 + (2 + (1)));
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int PLANE_U = (int)1;
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int VPX_IMG_FMT_HAS_ALPHA = (int)1024;
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int PLANE_V = (int)2;
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int PLANE_Y = (int)0;
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int IMG_FMT_HAS_ALPHA = (int)1024;
	/// <i>native declaration : vpx\vpx_decoder.h</i>
	public static final int VPX_CODEC_USE_POSTPROC = (int)65536;
	/// <i>native declaration : vpx\vpx_decoder.h</i>
	public static final int VPX_CODEC_CAP_ERROR_CONCEALMENT = (int)524288;
	/// <i>native declaration : vpx\vpx_codec.h</i>
	public static final int VPX_CODEC_MEM_ZERO = (int)1;
	/// <i>native declaration : vpx\vpx_decoder.h</i>
	public static final int VPX_DECODER_ABI_VERSION = (int)(2 + (2 + (1)));
	/// <i>native declaration : vpx\vpx_image.h</i>
	public static final int PLANE_PACKED = (int)0;
	/**
	 * \brief put frame callback prototype<br>
	 * * This callback is invoked by the decoder to notify the application of<br>
	 * the availability of decoded image data.<br>
	 * <i>native declaration : vpx\vpx_decoder.h</i>
	 */
	/**
	 * \brief put frame callback prototype<br>
	 * * This callback is invoked by the decoder to notify the application of<br>
	 * the availability of decoded image data.<br>
	 * <i>native declaration : vpx\vpx_decoder.h</i>
	 */
	public static abstract class vpx_codec_put_frame_cb_fn_t extends Callback<vpx_codec_put_frame_cb_fn_t > {
		abstract public void apply(Pointer<? > user_priv, Pointer<vpx_image_t > img);
	};
	/**
	 * \brief put slice callback prototype<br>
	 * * This callback is invoked by the decoder to notify the application of<br>
	 * the availability of partially decoded image data. The<br>
	 * <i>native declaration : vpx\vpx_decoder.h</i>
	 */
	/**
	 * \brief put slice callback prototype<br>
	 * * This callback is invoked by the decoder to notify the application of<br>
	 * the availability of partially decoded image data. The<br>
	 * <i>native declaration : vpx\vpx_decoder.h</i>
	 */
	public static abstract class vpx_codec_put_slice_cb_fn_t extends Callback<vpx_codec_put_slice_cb_fn_t > {
		abstract public void apply(Pointer<? > user_priv, Pointer<vpx_image_t > img, Pointer<vpx_image_rect_t > valid, Pointer<vpx_image_rect_t > update);
	};
	/**
	 * \brief Open a descriptor, allocating storage for the underlying image<br>
	 * * Returns a descriptor for storing an image of the given format. The<br>
	 * storage for the descriptor is allocated on the heap.<br>
	 * * \param[in]    img       Pointer to storage for descriptor. If this parameter<br>
	 *                         is NULL, the storage for the descriptor will be<br>
	 *                         allocated on the heap.<br>
	 * \param[in]    fmt       Format for the image<br>
	 * \param[in]    d_w       Width of the image<br>
	 * \param[in]    d_h       Height of the image<br>
	 * \param[in]    align     Alignment, in bytes, of the image buffer and<br>
	 *                         each row in the image(stride).<br>
	 * * \return Returns a pointer to the initialized image descriptor. If the img<br>
	 *         parameter is non-null, the value of the img parameter will be<br>
	 *         returned.<br>
	 * Original signature : <code>vpx_image_t* vpx_img_alloc(vpx_image_t*, vpx_img_fmt_t, unsigned int, unsigned int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vpx_image.h:170</i>
	 */
	synchronized public static Pointer<vpx_image_t > vpx_img_alloc(Pointer<vpx_image_t > img, IntValuedEnum<VpxLibrary.vpx_img_fmt_t > fmt, int d_w, int d_h, int align) {
		return Pointer.pointerToAddress(vpx_img_alloc(Pointer.getPeer(img), (int)fmt.value(), d_w, d_h, align), vpx_image_t.class);
	}
	@Ptr 
	synchronized protected native static long vpx_img_alloc(@Ptr long img, int fmt, int d_w, int d_h, int align);
	/**
	 * \brief Open a descriptor, using existing storage for the underlying image<br>
	 * * Returns a descriptor for storing an image of the given format. The<br>
	 * storage for descriptor has been allocated elsewhere, and a descriptor is<br>
	 * desired to "wrap" that storage.<br>
	 * * \param[in]    img       Pointer to storage for descriptor. If this parameter<br>
	 *                         is NULL, the storage for the descriptor will be<br>
	 *                         allocated on the heap.<br>
	 * \param[in]    fmt       Format for the image<br>
	 * \param[in]    d_w       Width of the image<br>
	 * \param[in]    d_h       Height of the image<br>
	 * \param[in]    align     Alignment, in bytes, of each row in the image.<br>
	 * \param[in]    img_data  Storage to use for the image<br>
	 * * \return Returns a pointer to the initialized image descriptor. If the img<br>
	 *         parameter is non-null, the value of the img parameter will be<br>
	 *         returned.<br>
	 * Original signature : <code>vpx_image_t* vpx_img_wrap(vpx_image_t*, vpx_img_fmt_t, unsigned int, unsigned int, unsigned int, unsigned char*)</code><br>
	 * <i>native declaration : vpx\vpx_image.h:195</i>
	 */
	synchronized public static Pointer<vpx_image_t > vpx_img_wrap(Pointer<vpx_image_t > img, IntValuedEnum<VpxLibrary.vpx_img_fmt_t > fmt, int d_w, int d_h, int align, Pointer<Byte > img_data) {
		return Pointer.pointerToAddress(vpx_img_wrap(Pointer.getPeer(img), (int)fmt.value(), d_w, d_h, align, Pointer.getPeer(img_data)), vpx_image_t.class);
	}
	@Ptr 
	synchronized protected native static long vpx_img_wrap(@Ptr long img, int fmt, int d_w, int d_h, int align, @Ptr long img_data);
	/**
	 * \brief Set the rectangle identifying the displayed portion of the image<br>
	 * * Updates the displayed rectangle (aka viewport) on the image surface to<br>
	 * match the specified coordinates and size.<br>
	 * * \param[in]    img       Image descriptor<br>
	 * \param[in]    x         leftmost column<br>
	 * \param[in]    y         topmost row<br>
	 * \param[in]    w         width<br>
	 * \param[in]    h         height<br>
	 * * \return 0 if the requested rectangle is valid, nonzero otherwise.<br>
	 * Original signature : <code>int vpx_img_set_rect(vpx_image_t*, unsigned int, unsigned int, unsigned int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vpx_image.h:216</i>
	 */
	synchronized public static int vpx_img_set_rect(Pointer<vpx_image_t > img, int x, int y, int w, int h) {
		return vpx_img_set_rect(Pointer.getPeer(img), x, y, w, h);
	}
	synchronized protected native static int vpx_img_set_rect(@Ptr long img, int x, int y, int w, int h);
	/**
	 * \brief Flip the image vertically (top for bottom)<br>
	 * * Adjusts the image descriptor's pointers and strides to make the image<br>
	 * be referenced upside-down.<br>
	 * * \param[in]    img       Image descriptor<br>
	 * Original signature : <code>void vpx_img_flip(vpx_image_t*)</code><br>
	 * <i>native declaration : vpx\vpx_image.h:230</i>
	 */
	synchronized public static void vpx_img_flip(Pointer<vpx_image_t > img) {
		vpx_img_flip(Pointer.getPeer(img));
	}
	synchronized protected native static void vpx_img_flip(@Ptr long img);
	/**
	 * \brief Close an image descriptor<br>
	 * * Frees all allocated storage associated with an image descriptor.<br>
	 * * \param[in]    img       Image descriptor<br>
	 * Original signature : <code>void vpx_img_free(vpx_image_t*)</code><br>
	 * <i>native declaration : vpx\vpx_image.h:238</i>
	 */
	synchronized public static void vpx_img_free(Pointer<vpx_image_t > img) {
		vpx_img_free(Pointer.getPeer(img));
	}
	synchronized protected native static void vpx_img_free(@Ptr long img);
	/**
	 * \brief Return the version information (as an integer)<br>
	 * * Returns a packed encoding of the library version number. This will only include<br>
	 * the major.minor.patch component of the version number. Note that this encoded<br>
	 * value should be accessed through the macros provided, as the encoding may change<br>
	 * in the future.<br>
	 * Original signature : <code>int vpx_codec_version()</code><br>
	 * <i>native declaration : vpx\vpx_codec.h:225</i>
	 */
	synchronized native public static int vpx_codec_version();
	/**
	 * \brief Return the version information (as a string)<br>
	 * * Returns a printable string containing the full library version number. This may<br>
	 * contain additional text following the three digit version number, as to indicate<br>
	 * release candidates, prerelease versions, etc.<br>
	 * Original signature : <code>char* vpx_codec_version_str()</code><br>
	 * <i>native declaration : vpx\vpx_codec.h:247</i>
	 */
	synchronized public static Pointer<Byte > vpx_codec_version_str() {
		return Pointer.pointerToAddress(vpx_codec_version_str$2(), Byte.class);
	}
	@Ptr 
	@Name("vpx_codec_version_str") 
	synchronized protected native static long vpx_codec_version_str$2();
	/**
	 * \brief Return the version information (as a string)<br>
	 * * Returns a printable "extra string". This is the component of the string returned<br>
	 * by vpx_codec_version_str() following the three digit version number.<br>
	 * Original signature : <code>char* vpx_codec_version_extra_str()</code><br>
	 * <i>native declaration : vpx\vpx_codec.h:256</i>
	 */
	synchronized public static Pointer<Byte > vpx_codec_version_extra_str() {
		return Pointer.pointerToAddress(vpx_codec_version_extra_str$2(), Byte.class);
	}
	@Ptr 
	@Name("vpx_codec_version_extra_str") 
	synchronized protected native static long vpx_codec_version_extra_str$2();
	/**
	 * \brief Return the build configuration<br>
	 * * Returns a printable string containing an encoded version of the build<br>
	 * configuration. This may be useful to vpx support.<br>
	 * Original signature : <code>char* vpx_codec_build_config()</code><br>
	 * <i>native declaration : vpx\vpx_codec.h:265</i>
	 */
	synchronized public static Pointer<Byte > vpx_codec_build_config() {
		return Pointer.pointerToAddress(vpx_codec_build_config$2(), Byte.class);
	}
	@Ptr 
	@Name("vpx_codec_build_config") 
	synchronized protected native static long vpx_codec_build_config$2();
	/**
	 * \brief Return the name for a given interface<br>
	 * * Returns a human readable string for name of the given codec interface.<br>
	 * * \param[in]    iface     Interface pointer<br>
	 * Original signature : <code>char* vpx_codec_iface_name(vpx_codec_iface_t*)</code><br>
	 * <i>native declaration : vpx\vpx_codec.h:275</i>
	 */
	synchronized public static Pointer<Byte > vpx_codec_iface_name(Pointer<VpxLibrary.vpx_codec_iface > iface) {
		return Pointer.pointerToAddress(vpx_codec_iface_name(Pointer.getPeer(iface)), Byte.class);
	}
	@Ptr 
	synchronized protected native static long vpx_codec_iface_name(@Ptr long iface);
	/**
	 * \brief Convert error number to printable string<br>
	 * * Returns a human readable string for the last error returned by the<br>
	 * algorithm. The returned error will be one line and will not contain<br>
	 * any newline characters.<br>
	 * *<br>
	 * \param[in]    err     Error number.<br>
	 * Original signature : <code>char* vpx_codec_err_to_string(vpx_codec_err_t)</code><br>
	 * <i>native declaration : vpx\vpx_codec.h:288</i>
	 */
	synchronized public static Pointer<Byte > vpx_codec_err_to_string(IntValuedEnum<VpxLibrary.vpx_codec_err_t > err) {
		return Pointer.pointerToAddress(vpx_codec_err_to_string((int)err.value()), Byte.class);
	}
	@Ptr 
	synchronized protected native static long vpx_codec_err_to_string(int err);
	/**
	 * \brief Retrieve error synopsis for codec context<br>
	 * * Returns a human readable string for the last error returned by the<br>
	 * algorithm. The returned error will be one line and will not contain<br>
	 * any newline characters.<br>
	 * *<br>
	 * \param[in]    ctx     Pointer to this instance's context.<br>
	 * Original signature : <code>char* vpx_codec_error(vpx_codec_ctx_t*)</code><br>
	 * <i>native declaration : vpx\vpx_codec.h:301</i>
	 */
	synchronized public static Pointer<Byte > vpx_codec_error(Pointer<vpx_codec_ctx_t > ctx) {
		return Pointer.pointerToAddress(vpx_codec_error(Pointer.getPeer(ctx)), Byte.class);
	}
	@Ptr 
	synchronized protected native static long vpx_codec_error(@Ptr long ctx);
	/**
	 * \brief Retrieve detailed error information for codec context<br>
	 * * Returns a human readable string providing detailed information about<br>
	 * the last error.<br>
	 * * \param[in]    ctx     Pointer to this instance's context.<br>
	 * * \retval NULL<br>
	 *     No detailed information is available.<br>
	 * Original signature : <code>char* vpx_codec_error_detail(vpx_codec_ctx_t*)</code><br>
	 * <i>native declaration : vpx\vpx_codec.h:314</i>
	 */
	synchronized public static Pointer<Byte > vpx_codec_error_detail(Pointer<vpx_codec_ctx_t > ctx) {
		return Pointer.pointerToAddress(vpx_codec_error_detail(Pointer.getPeer(ctx)), Byte.class);
	}
	@Ptr 
	synchronized protected native static long vpx_codec_error_detail(@Ptr long ctx);
	/**
	 * \brief Destroy a codec instance<br>
	 * * Destroys a codec context, freeing any associated memory buffers.<br>
	 * * \param[in] ctx   Pointer to this instance's context<br>
	 * * \retval #VPX_CODEC_OK<br>
	 *     The codec algorithm initialized.<br>
	 * \retval #VPX_CODEC_MEM_ERROR<br>
	 *     Memory allocation failed.<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_destroy(vpx_codec_ctx_t*)</code><br>
	 * <i>native declaration : vpx\vpx_codec.h:334</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_destroy(Pointer<vpx_codec_ctx_t > ctx) {
		return FlagSet.fromValue(vpx_codec_destroy(Pointer.getPeer(ctx)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_destroy(@Ptr long ctx);
	/**
	 * \brief Get the capabilities of an algorithm.<br>
	 * * Retrieves the capabilities bitfield from the algorithm's interface.<br>
	 * * \param[in] iface   Pointer to the algorithm interface<br>
	 * Original signature : <code>vpx_codec_caps_t vpx_codec_get_caps(vpx_codec_iface_t*)</code><br>
	 * <i>native declaration : vpx\vpx_codec.h:344</i>
	 */
	@CLong 
	synchronized public static long vpx_codec_get_caps(Pointer<VpxLibrary.vpx_codec_iface > iface) {
		return vpx_codec_get_caps(Pointer.getPeer(iface));
	}
	@CLong 
	synchronized protected native static long vpx_codec_get_caps(@Ptr long iface);
	/**
	 * \brief Control algorithm<br>
	 * * This function is used to exchange algorithm specific data with the codec<br>
	 * instance. This can be used to implement features specific to a particular<br>
	 * algorithm.<br>
	 * * This wrapper function dispatches the request to the helper function<br>
	 * associated with the given ctrl_id. It tries to call this function<br>
	 * transparently, but will return #VPX_CODEC_ERROR if the request could not<br>
	 * be dispatched.<br>
	 * * Note that this function should not be used directly. Call the<br>
	 * #vpx_codec_control wrapper macro instead.<br>
	 * * \param[in]     ctx              Pointer to this instance's context<br>
	 * \param[in]     ctrl_id          Algorithm specific control identifier<br>
	 * * \retval #VPX_CODEC_OK<br>
	 *     The control request was processed.<br>
	 * \retval #VPX_CODEC_ERROR<br>
	 *     The control request was not processed.<br>
	 * \retval #VPX_CODEC_INVALID_PARAM<br>
	 *     The data was not valid.<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_(vpx_codec_ctx_t*, int, null)</code><br>
	 * <i>native declaration : vpx\vpx_codec.h:371</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, Object... varargs) {
		return FlagSet.fromValue(vpx_codec_control_(Pointer.getPeer(ctx), ctrl_id), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_(@Ptr long ctx, int ctrl_id, Object... varargs);
	/**
	 * \brief Iterate over the list of segments to allocate.<br>
	 * * Iterates over a list of the segments to allocate. The iterator storage<br>
	 * should be initialized to NULL to start the iteration. Iteration is complete<br>
	 * when this function returns VPX_CODEC_LIST_END. The amount of memory needed to<br>
	 * allocate is dependent upon the size of the encoded stream. In cases where the<br>
	 * stream is not available at allocation time, a fixed size must be requested.<br>
	 * The codec will not be able to operate on streams larger than the size used at<br>
	 * allocation time.<br>
	 * * \param[in]      ctx     Pointer to this instance's context.<br>
	 * \param[out]     mmap    Pointer to the memory map entry to populate.<br>
	 * \param[in,out]  iter    Iterator storage, initialized to NULL<br>
	 * * \retval #VPX_CODEC_OK<br>
	 *     The memory map entry was populated.<br>
	 * \retval #VPX_CODEC_ERROR<br>
	 *     Codec does not support XMA mode.<br>
	 * \retval #VPX_CODEC_MEM_ERROR<br>
	 *     Unable to determine segment size from stream info.<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_get_mem_map(vpx_codec_ctx_t*, vpx_codec_mmap_t*, vpx_codec_iter_t*)</code><br>
	 * <i>native declaration : vpx\vpx_codec.h:515</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_get_mem_map(Pointer<vpx_codec_ctx_t > ctx, Pointer<vpx_codec_mmap_t > mmap, Pointer<Pointer<? > > iter) {
		return FlagSet.fromValue(vpx_codec_get_mem_map(Pointer.getPeer(ctx), Pointer.getPeer(mmap), Pointer.getPeer(iter)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_get_mem_map(@Ptr long ctx, @Ptr long mmap, @Ptr long iter);
	/**
	 * \brief Identify allocated segments to codec instance<br>
	 * * Stores a list of allocated segments in the codec. Segments \ref MUST be<br>
	 * passed in the order they are read from vpx_codec_get_mem_map(), but may be<br>
	 * passed in groups of any size. Segments \ref MUST be set only once. The<br>
	 * allocation function \ref MUST ensure that the vpx_codec_mmap_t::base member<br>
	 * is non-NULL. If the segment requires cleanup handling (e.g., calling free()<br>
	 * or close()) then the vpx_codec_mmap_t::dtor member \ref MUST be populated.<br>
	 * * \param[in]      ctx     Pointer to this instance's context.<br>
	 * \param[in]      mmaps   Pointer to the first memory map entry in the list.<br>
	 * \param[in]      num_maps  Number of entries being set at this time<br>
	 * * \retval #VPX_CODEC_OK<br>
	 *     The segment was stored in the codec context.<br>
	 * \retval #VPX_CODEC_INCAPABLE<br>
	 *     Codec does not support XMA mode.<br>
	 * \retval #VPX_CODEC_MEM_ERROR<br>
	 *     Segment base address was not set, or segment was already stored.<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_set_mem_map(vpx_codec_ctx_t*, vpx_codec_mmap_t*, unsigned int)</code><br>
	 * <i>native declaration : vpx\vpx_codec.h:541</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_set_mem_map(Pointer<vpx_codec_ctx_t > ctx, Pointer<vpx_codec_mmap_t > mmaps, int num_maps) {
		return FlagSet.fromValue(vpx_codec_set_mem_map(Pointer.getPeer(ctx), Pointer.getPeer(mmaps), num_maps), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_set_mem_map(@Ptr long ctx, @Ptr long mmaps, int num_maps);
	/**
	 * \brief Initialize an encoder instance<br>
	 * * Initializes a encoder context using the given interface. Applications<br>
	 * should call the vpx_codec_enc_init convenience macro instead of this<br>
	 * function directly, to ensure that the ABI version number parameter<br>
	 * is properly initialized.<br>
	 * * If the library was configured with --disable-multithread, this call<br>
	 * is not thread safe and should be guarded with a lock if being used<br>
	 * in a multithreaded context.<br>
	 * * In XMA mode (activated by setting VPX_CODEC_USE_XMA in the flags<br>
	 * parameter), the storage pointed to by the cfg parameter must be<br>
	 * kept readable and stable until all memory maps have been set.<br>
	 * * \param[in]    ctx     Pointer to this instance's context.<br>
	 * \param[in]    iface   Pointer to the algorithm interface to use.<br>
	 * \param[in]    cfg     Configuration to use, if known. May be NULL.<br>
	 * \param[in]    flags   Bitfield of VPX_CODEC_USE_* flags<br>
	 * \param[in]    ver     ABI version number. Must be set to<br>
	 *                       VPX_ENCODER_ABI_VERSION<br>
	 * \retval #VPX_CODEC_OK<br>
	 *     The decoder algorithm initialized.<br>
	 * \retval #VPX_CODEC_MEM_ERROR<br>
	 *     Memory allocation failed.<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_enc_init_ver(vpx_codec_ctx_t*, vpx_codec_iface_t*, vpx_codec_enc_cfg_t*, vpx_codec_flags_t, int)</code><br>
	 * <i>native declaration : vpx\vpx_encoder.h:663</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_enc_init_ver(Pointer<vpx_codec_ctx_t > ctx, Pointer<VpxLibrary.vpx_codec_iface > iface, Pointer<vpx_codec_enc_cfg_t > cfg, @CLong long flags, int ver) {
		return FlagSet.fromValue(vpx_codec_enc_init_ver(Pointer.getPeer(ctx), Pointer.getPeer(iface), Pointer.getPeer(cfg), flags, ver), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_enc_init_ver(@Ptr long ctx, @Ptr long iface, @Ptr long cfg, @CLong long flags, int ver);
	/**
	 * \brief Initialize multi-encoder instance<br>
	 * * Initializes multi-encoder context using the given interface.<br>
	 * Applications should call the vpx_codec_enc_init_multi convenience macro<br>
	 * instead of this function directly, to ensure that the ABI version number<br>
	 * parameter is properly initialized.<br>
	 * * In XMA mode (activated by setting VPX_CODEC_USE_XMA in the flags<br>
	 * parameter), the storage pointed to by the cfg parameter must be<br>
	 * kept readable and stable until all memory maps have been set.<br>
	 * * \param[in]    ctx     Pointer to this instance's context.<br>
	 * \param[in]    iface   Pointer to the algorithm interface to use.<br>
	 * \param[in]    cfg     Configuration to use, if known. May be NULL.<br>
	 * \param[in]    num_enc Total number of encoders.<br>
	 * \param[in]    flags   Bitfield of VPX_CODEC_USE_* flags<br>
	 * \param[in]    dsf     Pointer to down-sampling factors.<br>
	 * \param[in]    ver     ABI version number. Must be set to<br>
	 *                       VPX_ENCODER_ABI_VERSION<br>
	 * \retval #VPX_CODEC_OK<br>
	 *     The decoder algorithm initialized.<br>
	 * \retval #VPX_CODEC_MEM_ERROR<br>
	 *     Memory allocation failed.<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_enc_init_multi_ver(vpx_codec_ctx_t*, vpx_codec_iface_t*, vpx_codec_enc_cfg_t*, int, vpx_codec_flags_t, vpx_rational_t*, int)</code><br>
	 * <i>native declaration : vpx\vpx_encoder.h:702</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_enc_init_multi_ver(Pointer<vpx_codec_ctx_t > ctx, Pointer<VpxLibrary.vpx_codec_iface > iface, Pointer<vpx_codec_enc_cfg_t > cfg, int num_enc, @CLong long flags, Pointer<vpx_rational_t > dsf, int ver) {
		return FlagSet.fromValue(vpx_codec_enc_init_multi_ver(Pointer.getPeer(ctx), Pointer.getPeer(iface), Pointer.getPeer(cfg), num_enc, flags, Pointer.getPeer(dsf), ver), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_enc_init_multi_ver(@Ptr long ctx, @Ptr long iface, @Ptr long cfg, int num_enc, @CLong long flags, @Ptr long dsf, int ver);
	/**
	 * \brief Get a default configuration<br>
	 * * Initializes a encoder configuration structure with default values. Supports<br>
	 * the notion of "usages" so that an algorithm may offer different default<br>
	 * settings depending on the user's intended goal. This function \ref SHOULD<br>
	 * be called by all applications to initialize the configuration structure<br>
	 * before specializing the configuration with application specific values.<br>
	 * * \param[in]    iface   Pointer to the algorithm interface to use.<br>
	 * \param[out]   cfg     Configuration buffer to populate<br>
	 * \param[in]    usage   End usage. Set to 0 or use codec specific values.<br>
	 * * \retval #VPX_CODEC_OK<br>
	 *     The configuration was populated.<br>
	 * \retval #VPX_CODEC_INCAPABLE<br>
	 *     Interface is not an encoder interface.<br>
	 * \retval #VPX_CODEC_INVALID_PARAM<br>
	 *     A parameter was NULL, or the usage value was not recognized.<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_enc_config_default(vpx_codec_iface_t*, vpx_codec_enc_cfg_t*, unsigned int)</code><br>
	 * <i>native declaration : vpx\vpx_encoder.h:739</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_enc_config_default(Pointer<VpxLibrary.vpx_codec_iface > iface, Pointer<vpx_codec_enc_cfg_t > cfg, int usage) {
		return FlagSet.fromValue(vpx_codec_enc_config_default(Pointer.getPeer(iface), Pointer.getPeer(cfg), usage), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_enc_config_default(@Ptr long iface, @Ptr long cfg, int usage);
	/**
	 * \brief Set or change configuration<br>
	 * * Reconfigures an encoder instance according to the given configuration.<br>
	 * * \param[in]    ctx     Pointer to this instance's context<br>
	 * \param[in]    cfg     Configuration buffer to use<br>
	 * * \retval #VPX_CODEC_OK<br>
	 *     The configuration was populated.<br>
	 * \retval #VPX_CODEC_INCAPABLE<br>
	 *     Interface is not an encoder interface.<br>
	 * \retval #VPX_CODEC_INVALID_PARAM<br>
	 *     A parameter was NULL, or the usage value was not recognized.<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_enc_config_set(vpx_codec_ctx_t*, const vpx_codec_enc_cfg_t*)</code><br>
	 * <i>native declaration : vpx\vpx_encoder.h:758</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_enc_config_set(Pointer<vpx_codec_ctx_t > ctx, Pointer<vpx_codec_enc_cfg_t > cfg) {
		return FlagSet.fromValue(vpx_codec_enc_config_set(Pointer.getPeer(ctx), Pointer.getPeer(cfg)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_enc_config_set(@Ptr long ctx, @Ptr long cfg);
	/**
	 * \brief Get global stream headers<br>
	 * * Retrieves a stream level global header packet, if supported by the codec.<br>
	 * * \param[in]    ctx     Pointer to this instance's context<br>
	 * * \retval NULL<br>
	 *     Encoder does not support global header<br>
	 * \retval Non-NULL<br>
	 *     Pointer to buffer containing global header packet<br>
	 * Original signature : <code>vpx_fixed_buf_t* vpx_codec_get_global_headers(vpx_codec_ctx_t*)</code><br>
	 * <i>native declaration : vpx\vpx_encoder.h:773</i>
	 */
	synchronized public static Pointer<vpx_fixed_buf_t > vpx_codec_get_global_headers(Pointer<vpx_codec_ctx_t > ctx) {
		return Pointer.pointerToAddress(vpx_codec_get_global_headers(Pointer.getPeer(ctx)), vpx_fixed_buf_t.class);
	}
	@Ptr 
	synchronized protected native static long vpx_codec_get_global_headers(@Ptr long ctx);
	/**
	 * \brief Encode a frame<br>
	 * * Encodes a video frame at the given "presentation time." The presentation<br>
	 * time stamp (PTS) \ref MUST be strictly increasing.<br>
	 * * The encoder supports the notion of a soft real-time deadline. Given a<br>
	 * non-zero value to the deadline parameter, the encoder will make a "best<br>
	 * effort" guarantee to  return before the given time slice expires. It is<br>
	 * implicit that limiting the available time to encode will degrade the<br>
	 * output quality. The encoder can be given an unlimited time to produce the<br>
	 * best possible frame by specifying a deadline of '0'. This deadline<br>
	 * supercedes the VPx notion of "best quality, good quality, realtime".<br>
	 * Applications that wish to map these former settings to the new deadline<br>
	 * based system can use the symbols #VPX_DL_REALTIME, #VPX_DL_GOOD_QUALITY,<br>
	 * and #VPX_DL_BEST_QUALITY.<br>
	 * * When the last frame has been passed to the encoder, this function should<br>
	 * continue to be called, with the img parameter set to NULL. This will<br>
	 * signal the end-of-stream condition to the encoder and allow it to encode<br>
	 * any held buffers. Encoding is complete when vpx_codec_encode() is called<br>
	 * and vpx_codec_get_cx_data() returns no data.<br>
	 * * \param[in]    ctx       Pointer to this instance's context<br>
	 * \param[in]    img       Image data to encode, NULL to flush.<br>
	 * \param[in]    pts       Presentation time stamp, in timebase units.<br>
	 * \param[in]    duration  Duration to show frame, in timebase units.<br>
	 * \param[in]    flags     Flags to use for encoding this frame.<br>
	 * \param[in]    deadline  Time to spend encoding, in microseconds. (0=infinite)<br>
	 * * \retval #VPX_CODEC_OK<br>
	 *     The configuration was populated.<br>
	 * \retval #VPX_CODEC_INCAPABLE<br>
	 *     Interface is not an encoder interface.<br>
	 * \retval #VPX_CODEC_INVALID_PARAM<br>
	 *     A parameter was NULL, the image format is unsupported, etc.<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_encode(vpx_codec_ctx_t*, const vpx_image_t*, vpx_codec_pts_t, unsigned long, vpx_enc_frame_flags_t, unsigned long)</code><br>
	 * <i>native declaration : vpx\vpx_encoder.h:815</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_encode(Pointer<vpx_codec_ctx_t > ctx, Pointer<vpx_image_t > img, long pts, @CLong long duration, @CLong long flags, @CLong long deadline) {
		return FlagSet.fromValue(vpx_codec_encode(Pointer.getPeer(ctx), Pointer.getPeer(img), pts, duration, flags, deadline), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_encode(@Ptr long ctx, @Ptr long img, long pts, @CLong long duration, @CLong long flags, @CLong long deadline);
	/**
	 * \brief Set compressed data output buffer<br>
	 * * Sets the buffer that the codec should output the compressed data<br>
	 * into. This call effectively sets the buffer pointer returned in the<br>
	 * next VPX_CODEC_CX_FRAME_PKT packet. Subsequent packets will be<br>
	 * appended into this buffer. The buffer is preserved across frames,<br>
	 * so applications must periodically call this function after flushing<br>
	 * the accumulated compressed data to disk or to the network to reset<br>
	 * the pointer to the buffer's head.<br>
	 * * `pad_before` bytes will be skipped before writing the compressed<br>
	 * data, and `pad_after` bytes will be appended to the packet. The size<br>
	 * of the packet will be the sum of the size of the actual compressed<br>
	 * data, pad_before, and pad_after. The padding bytes will be preserved<br>
	 * (not overwritten).<br>
	 * * Note that calling this function does not guarantee that the returned<br>
	 * compressed data will be placed into the specified buffer. In the<br>
	 * event that the encoded data will not fit into the buffer provided,<br>
	 * the returned packet \ref MAY point to an internal buffer, as it would<br>
	 * if this call were never used. In this event, the output packet will<br>
	 * NOT have any padding, and the application must free space and copy it<br>
	 * to the proper place. This is of particular note in configurations<br>
	 * that may output multiple packets for a single encoded frame (e.g., lagged<br>
	 * encoding) or if the application does not reset the buffer periodically.<br>
	 * * Applications may restore the default behavior of the codec providing<br>
	 * the compressed data buffer by calling this function with a NULL<br>
	 * buffer.<br>
	 * * Applications \ref MUSTNOT call this function during iteration of<br>
	 * vpx_codec_get_cx_data().<br>
	 * * \param[in]    ctx         Pointer to this instance's context<br>
	 * \param[in]    buf         Buffer to store compressed data into<br>
	 * \param[in]    pad_before  Bytes to skip before writing compressed data<br>
	 * \param[in]    pad_after   Bytes to skip after writing compressed data<br>
	 * * \retval #VPX_CODEC_OK<br>
	 *     The buffer was set successfully.<br>
	 * \retval #VPX_CODEC_INVALID_PARAM<br>
	 *     A parameter was NULL, the image format is unsupported, etc.<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_set_cx_data_buf(vpx_codec_ctx_t*, const vpx_fixed_buf_t*, unsigned int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vpx_encoder.h:865</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_set_cx_data_buf(Pointer<vpx_codec_ctx_t > ctx, Pointer<vpx_fixed_buf_t > buf, int pad_before, int pad_after) {
		return FlagSet.fromValue(vpx_codec_set_cx_data_buf(Pointer.getPeer(ctx), Pointer.getPeer(buf), pad_before, pad_after), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_set_cx_data_buf(@Ptr long ctx, @Ptr long buf, int pad_before, int pad_after);
	/**
	 * \brief Encoded data iterator<br>
	 * * Iterates over a list of data packets to be passed from the encoder to the<br>
	 * application. The different kinds of packets available are enumerated in<br>
	 * #vpx_codec_cx_pkt_kind.<br>
	 * * #VPX_CODEC_CX_FRAME_PKT packets should be passed to the application's<br>
	 * muxer. Multiple compressed frames may be in the list.<br>
	 * #VPX_CODEC_STATS_PKT packets should be appended to a global buffer.<br>
	 * * The application \ref MUST silently ignore any packet kinds that it does<br>
	 * not recognize or support.<br>
	 * * The data buffers returned from this function are only guaranteed to be<br>
	 * valid until the application makes another call to any vpx_codec_* function.<br>
	 * * \param[in]     ctx      Pointer to this instance's context<br>
	 * \param[in,out] iter     Iterator storage, initialized to NULL<br>
	 * * \return Returns a pointer to an output data packet (compressed frame data,<br>
	 *         two-pass statistics, etc.) or NULL to signal end-of-list.<br>
	 * Original signature : <code>vpx_codec_cx_pkt_t* vpx_codec_get_cx_data(vpx_codec_ctx_t*, vpx_codec_iter_t*)</code><br>
	 * <i>native declaration : vpx\vpx_encoder.h:894</i>
	 */
	synchronized public static Pointer<vpx_codec_cx_pkt_t > vpx_codec_get_cx_data(Pointer<vpx_codec_ctx_t > ctx, Pointer<Pointer<? > > iter) {
		return Pointer.pointerToAddress(vpx_codec_get_cx_data(Pointer.getPeer(ctx), Pointer.getPeer(iter)), vpx_codec_cx_pkt_t.class);
	}
	@Ptr 
	synchronized protected native static long vpx_codec_get_cx_data(@Ptr long ctx, @Ptr long iter);
	/**
	 * \brief Get Preview Frame<br>
	 * * Returns an image that can be used as a preview. Shows the image as it would<br>
	 * exist at the decompressor. The application \ref MUST NOT write into this<br>
	 * image buffer.<br>
	 * * \param[in]     ctx      Pointer to this instance's context<br>
	 * * \return Returns a pointer to a preview image, or NULL if no image is<br>
	 *         available.<br>
	 * Original signature : <code>vpx_image_t* vpx_codec_get_preview_frame(vpx_codec_ctx_t*)</code><br>
	 * <i>native declaration : vpx\vpx_encoder.h:910</i>
	 */
	synchronized public static Pointer<vpx_image_t > vpx_codec_get_preview_frame(Pointer<vpx_codec_ctx_t > ctx) {
		return Pointer.pointerToAddress(vpx_codec_get_preview_frame(Pointer.getPeer(ctx)), vpx_image_t.class);
	}
	@Ptr 
	synchronized protected native static long vpx_codec_get_preview_frame(@Ptr long ctx);
	/**
	 * \brief Initialize a decoder instance<br>
	 * * Initializes a decoder context using the given interface. Applications<br>
	 * should call the vpx_codec_dec_init convenience macro instead of this<br>
	 * function directly, to ensure that the ABI version number parameter<br>
	 * is properly initialized.<br>
	 * * If the library was configured with --disable-multithread, this call<br>
	 * is not thread safe and should be guarded with a lock if being used<br>
	 * in a multithreaded context.<br>
	 * * In XMA mode (activated by setting VPX_CODEC_USE_XMA in the flags<br>
	 * parameter), the storage pointed to by the cfg parameter must be<br>
	 * kept readable and stable until all memory maps have been set.<br>
	 * * \param[in]    ctx     Pointer to this instance's context.<br>
	 * \param[in]    iface   Pointer to the algorithm interface to use.<br>
	 * \param[in]    cfg     Configuration to use, if known. May be NULL.<br>
	 * \param[in]    flags   Bitfield of VPX_CODEC_USE_* flags<br>
	 * \param[in]    ver     ABI version number. Must be set to<br>
	 *                       VPX_DECODER_ABI_VERSION<br>
	 * \retval #VPX_CODEC_OK<br>
	 *     The decoder algorithm initialized.<br>
	 * \retval #VPX_CODEC_MEM_ERROR<br>
	 *     Memory allocation failed.<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_dec_init_ver(vpx_codec_ctx_t*, vpx_codec_iface_t*, vpx_codec_dec_cfg_t*, vpx_codec_flags_t, int)</code><br>
	 * <i>native declaration : vpx\vpx_decoder.h:129</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_dec_init_ver(Pointer<vpx_codec_ctx_t > ctx, Pointer<VpxLibrary.vpx_codec_iface > iface, Pointer<vpx_codec_dec_cfg_t > cfg, @CLong long flags, int ver) {
		return FlagSet.fromValue(vpx_codec_dec_init_ver(Pointer.getPeer(ctx), Pointer.getPeer(iface), Pointer.getPeer(cfg), flags, ver), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_dec_init_ver(@Ptr long ctx, @Ptr long iface, @Ptr long cfg, @CLong long flags, int ver);
	/**
	 * \brief Parse stream info from a buffer<br>
	 * * Performs high level parsing of the bitstream. Construction of a decoder<br>
	 * context is not necessary. Can be used to determine if the bitstream is<br>
	 * of the proper format, and to extract information from the stream.<br>
	 * * \param[in]      iface   Pointer to the algorithm interface<br>
	 * \param[in]      data    Pointer to a block of data to parse<br>
	 * \param[in]      data_sz Size of the data buffer<br>
	 * \param[in,out]  si      Pointer to stream info to update. The size member<br>
	 *                         \ref MUST be properly initialized, but \ref MAY be<br>
	 *                         clobbered by the algorithm. This parameter \ref MAY<br>
	 *                         be NULL.<br>
	 * * \retval #VPX_CODEC_OK<br>
	 *     Bitstream is parsable and stream information updated<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_peek_stream_info(vpx_codec_iface_t*, const uint8_t*, unsigned int, vpx_codec_stream_info_t*)</code><br>
	 * <i>native declaration : vpx\vpx_decoder.h:160</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_peek_stream_info(Pointer<VpxLibrary.vpx_codec_iface > iface, Pointer<Byte > data, int data_sz, Pointer<vpx_codec_stream_info_t > si) {
		return FlagSet.fromValue(vpx_codec_peek_stream_info(Pointer.getPeer(iface), Pointer.getPeer(data), data_sz, Pointer.getPeer(si)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_peek_stream_info(@Ptr long iface, @Ptr long data, int data_sz, @Ptr long si);
	/**
	 * \brief Return information about the current stream.<br>
	 * * Returns information about the stream that has been parsed during decoding.<br>
	 * * \param[in]      ctx     Pointer to this instance's context<br>
	 * \param[in,out]  si      Pointer to stream info to update. The size member<br>
	 *                         \ref MUST be properly initialized, but \ref MAY be<br>
	 *                         clobbered by the algorithm. This parameter \ref MAY<br>
	 *                         be NULL.<br>
	 * * \retval #VPX_CODEC_OK<br>
	 *     Bitstream is parsable and stream information updated<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_get_stream_info(vpx_codec_ctx_t*, vpx_codec_stream_info_t*)</code><br>
	 * <i>native declaration : vpx\vpx_decoder.h:179</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_get_stream_info(Pointer<vpx_codec_ctx_t > ctx, Pointer<vpx_codec_stream_info_t > si) {
		return FlagSet.fromValue(vpx_codec_get_stream_info(Pointer.getPeer(ctx), Pointer.getPeer(si)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_get_stream_info(@Ptr long ctx, @Ptr long si);
	/**
	 * \brief Decode data<br>
	 * * Processes a buffer of coded data. If the processing results in a new<br>
	 * decoded frame becoming available, PUT_SLICE and PUT_FRAME events may be<br>
	 * generated, as appropriate. Encoded data \ref MUST be passed in DTS (decode<br>
	 * time stamp) order. Frames produced will always be in PTS (presentation<br>
	 * time stamp) order.<br>
	 * If the decoder is configured with VPX_CODEC_USE_INPUT_FRAGMENTS enabled,<br>
	 * data and data_sz can contain a fragment of the encoded frame. Fragment<br>
	 * \#n must contain at least partition \#n, but can also contain subsequent<br>
	 * partitions (\#n+1 - \#n+i), and if so, fragments \#n+1, .., \#n+i must<br>
	 * be empty. When no more data is available, this function should be called<br>
	 * with NULL as data and 0 as data_sz. The memory passed to this function<br>
	 * must be available until the frame has been decoded.<br>
	 * * \param[in] ctx          Pointer to this instance's context<br>
	 * \param[in] data         Pointer to this block of new coded data. If<br>
	 *                         NULL, a VPX_CODEC_CB_PUT_FRAME event is posted<br>
	 *                         for the previously decoded frame.<br>
	 * \param[in] data_sz      Size of the coded data, in bytes.<br>
	 * \param[in] user_priv    Application specific data to associate with<br>
	 *                         this frame.<br>
	 * \param[in] deadline     Soft deadline the decoder should attempt to meet,<br>
	 *                         in us. Set to zero for unlimited.<br>
	 * * \return Returns #VPX_CODEC_OK if the coded data was processed completely<br>
	 *         and future pictures can be decoded without error. Otherwise,<br>
	 *         see the descriptions of the other error codes in ::vpx_codec_err_t<br>
	 *         for recoverability capabilities.<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_decode(vpx_codec_ctx_t*, const uint8_t*, unsigned int, void*, long)</code><br>
	 * <i>native declaration : vpx\vpx_decoder.h:213</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_decode(Pointer<vpx_codec_ctx_t > ctx, Pointer<Byte > data, int data_sz, Pointer<? > user_priv, @CLong long deadline) {
		return FlagSet.fromValue(vpx_codec_decode(Pointer.getPeer(ctx), Pointer.getPeer(data), data_sz, Pointer.getPeer(user_priv), deadline), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_decode(@Ptr long ctx, @Ptr long data, int data_sz, @Ptr long user_priv, @CLong long deadline);
	/**
	 * \brief Decoded frames iterator<br>
	 * * Iterates over a list of the frames available for display. The iterator<br>
	 * storage should be initialized to NULL to start the iteration. Iteration is<br>
	 * complete when this function returns NULL.<br>
	 * * The list of available frames becomes valid upon completion of the<br>
	 * vpx_codec_decode call, and remains valid until the next call to vpx_codec_decode.<br>
	 * * \param[in]     ctx      Pointer to this instance's context<br>
	 * \param[in,out] iter     Iterator storage, initialized to NULL<br>
	 * * \return Returns a pointer to an image, if one is ready for display. Frames<br>
	 *         produced will always be in PTS (presentation time stamp) order.<br>
	 * Original signature : <code>vpx_image_t* vpx_codec_get_frame(vpx_codec_ctx_t*, vpx_codec_iter_t*)</code><br>
	 * <i>native declaration : vpx\vpx_decoder.h:235</i>
	 */
	synchronized public static Pointer<vpx_image_t > vpx_codec_get_frame(Pointer<vpx_codec_ctx_t > ctx, Pointer<Pointer<? > > iter) {
		return Pointer.pointerToAddress(vpx_codec_get_frame(Pointer.getPeer(ctx), Pointer.getPeer(iter)), vpx_image_t.class);
	}
	@Ptr 
	synchronized protected native static long vpx_codec_get_frame(@Ptr long ctx, @Ptr long iter);
	/**
	 * \brief Register for notification of frame completion.<br>
	 * * Registers a given function to be called when a decoded frame is<br>
	 * available.<br>
	 * * \param[in] ctx          Pointer to this instance's context<br>
	 * \param[in] cb           Pointer to the callback function<br>
	 * \param[in] user_priv    User's private data<br>
	 * * \retval #VPX_CODEC_OK<br>
	 *     Callback successfully registered.<br>
	 * \retval #VPX_CODEC_ERROR<br>
	 *     Decoder context not initialized, or algorithm not capable of<br>
	 *     posting slice completion.<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_register_put_frame_cb(vpx_codec_ctx_t*, vpx_codec_put_frame_cb_fn_t, void*)</code><br>
	 * <i>native declaration : vpx\vpx_decoder.h:272</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_register_put_frame_cb(Pointer<vpx_codec_ctx_t > ctx, Pointer<VpxLibrary.vpx_codec_put_frame_cb_fn_t > cb, Pointer<? > user_priv) {
		return FlagSet.fromValue(vpx_codec_register_put_frame_cb(Pointer.getPeer(ctx), Pointer.getPeer(cb), Pointer.getPeer(user_priv)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_register_put_frame_cb(@Ptr long ctx, @Ptr long cb, @Ptr long user_priv);
	/**
	 * \brief Register for notification of slice completion.<br>
	 * * Registers a given function to be called when a decoded slice is<br>
	 * available.<br>
	 * * \param[in] ctx          Pointer to this instance's context<br>
	 * \param[in] cb           Pointer to the callback function<br>
	 * \param[in] user_priv    User's private data<br>
	 * * \retval #VPX_CODEC_OK<br>
	 *     Callback successfully registered.<br>
	 * \retval #VPX_CODEC_ERROR<br>
	 *     Decoder context not initialized, or algorithm not capable of<br>
	 *     posting slice completion.<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_register_put_slice_cb(vpx_codec_ctx_t*, vpx_codec_put_slice_cb_fn_t, void*)</code><br>
	 * <i>native declaration : vpx\vpx_decoder.h:314</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_register_put_slice_cb(Pointer<vpx_codec_ctx_t > ctx, Pointer<VpxLibrary.vpx_codec_put_slice_cb_fn_t > cb, Pointer<? > user_priv) {
		return FlagSet.fromValue(vpx_codec_register_put_slice_cb(Pointer.getPeer(ctx), Pointer.getPeer(cb), Pointer.getPeer(user_priv)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_register_put_slice_cb(@Ptr long ctx, @Ptr long cb, @Ptr long user_priv);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8_SET_REFERENCE(vpx_codec_ctx_t*, int, vpx_ref_frame_t*)</code><br>
	 * <i>native declaration : vpx\vp8.h:110</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8_SET_REFERENCE(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, Pointer<vpx_ref_frame_t > vpx_ref_frame_tPtr1) {
		return FlagSet.fromValue(vpx_codec_control_VP8_SET_REFERENCE(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, Pointer.getPeer(vpx_ref_frame_tPtr1)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8_SET_REFERENCE(@Ptr long vpx_codec_ctx_tPtr1, int int1, @Ptr long vpx_ref_frame_tPtr1);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8_SET_REFERENCE(vpx_codec_ctx_t*, int, vpx_ref_frame_t*)</code><br>
	 * <i>native declaration : vpx\vp8.h:110</i>
	 */
	@Name("vpx_codec_control_VP8_SET_REFERENCE") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8_SET_REFERENCE$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, Pointer<vpx_ref_frame_t > data) {
		return FlagSet.fromValue(vpx_codec_control_VP8_SET_REFERENCE$2(Pointer.getPeer(ctx), ctrl_id, Pointer.getPeer(data)), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8_SET_REFERENCE") 
	synchronized protected native static int vpx_codec_control_VP8_SET_REFERENCE$2(@Ptr long ctx, int ctrl_id, @Ptr long data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8_COPY_REFERENCE(vpx_codec_ctx_t*, int, vpx_ref_frame_t*)</code><br>
	 * <i>native declaration : vpx\vp8.h:111</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8_COPY_REFERENCE(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, Pointer<vpx_ref_frame_t > vpx_ref_frame_tPtr1) {
		return FlagSet.fromValue(vpx_codec_control_VP8_COPY_REFERENCE(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, Pointer.getPeer(vpx_ref_frame_tPtr1)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8_COPY_REFERENCE(@Ptr long vpx_codec_ctx_tPtr1, int int1, @Ptr long vpx_ref_frame_tPtr1);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8_COPY_REFERENCE(vpx_codec_ctx_t*, int, vpx_ref_frame_t*)</code><br>
	 * <i>native declaration : vpx\vp8.h:111</i>
	 */
	@Name("vpx_codec_control_VP8_COPY_REFERENCE") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8_COPY_REFERENCE$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, Pointer<vpx_ref_frame_t > data) {
		return FlagSet.fromValue(vpx_codec_control_VP8_COPY_REFERENCE$2(Pointer.getPeer(ctx), ctrl_id, Pointer.getPeer(data)), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8_COPY_REFERENCE") 
	synchronized protected native static int vpx_codec_control_VP8_COPY_REFERENCE$2(@Ptr long ctx, int ctrl_id, @Ptr long data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8_SET_POSTPROC(vpx_codec_ctx_t*, int, vp8_postproc_cfg_t*)</code><br>
	 * <i>native declaration : vpx\vp8.h:112</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8_SET_POSTPROC(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, Pointer<vp8_postproc_cfg_t > vp8_postproc_cfg_tPtr1) {
		return FlagSet.fromValue(vpx_codec_control_VP8_SET_POSTPROC(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, Pointer.getPeer(vp8_postproc_cfg_tPtr1)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8_SET_POSTPROC(@Ptr long vpx_codec_ctx_tPtr1, int int1, @Ptr long vp8_postproc_cfg_tPtr1);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8_SET_POSTPROC(vpx_codec_ctx_t*, int, vp8_postproc_cfg_t*)</code><br>
	 * <i>native declaration : vpx\vp8.h:112</i>
	 */
	@Name("vpx_codec_control_VP8_SET_POSTPROC") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8_SET_POSTPROC$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, Pointer<vp8_postproc_cfg_t > data) {
		return FlagSet.fromValue(vpx_codec_control_VP8_SET_POSTPROC$2(Pointer.getPeer(ctx), ctrl_id, Pointer.getPeer(data)), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8_SET_POSTPROC") 
	synchronized protected native static int vpx_codec_control_VP8_SET_POSTPROC$2(@Ptr long ctx, int ctrl_id, @Ptr long data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8_SET_DBG_COLOR_REF_FRAME(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8.h:113</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8_SET_DBG_COLOR_REF_FRAME(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8_SET_DBG_COLOR_REF_FRAME(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8_SET_DBG_COLOR_REF_FRAME(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8_SET_DBG_COLOR_REF_FRAME(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8.h:113</i>
	 */
	@Name("vpx_codec_control_VP8_SET_DBG_COLOR_REF_FRAME") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8_SET_DBG_COLOR_REF_FRAME$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8_SET_DBG_COLOR_REF_FRAME$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8_SET_DBG_COLOR_REF_FRAME") 
	synchronized protected native static int vpx_codec_control_VP8_SET_DBG_COLOR_REF_FRAME$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8_SET_DBG_COLOR_MB_MODES(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8.h:114</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8_SET_DBG_COLOR_MB_MODES(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8_SET_DBG_COLOR_MB_MODES(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8_SET_DBG_COLOR_MB_MODES(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8_SET_DBG_COLOR_MB_MODES(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8.h:114</i>
	 */
	@Name("vpx_codec_control_VP8_SET_DBG_COLOR_MB_MODES") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8_SET_DBG_COLOR_MB_MODES$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8_SET_DBG_COLOR_MB_MODES$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8_SET_DBG_COLOR_MB_MODES") 
	synchronized protected native static int vpx_codec_control_VP8_SET_DBG_COLOR_MB_MODES$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8_SET_DBG_COLOR_B_MODES(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8.h:115</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8_SET_DBG_COLOR_B_MODES(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8_SET_DBG_COLOR_B_MODES(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8_SET_DBG_COLOR_B_MODES(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8_SET_DBG_COLOR_B_MODES(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8.h:115</i>
	 */
	@Name("vpx_codec_control_VP8_SET_DBG_COLOR_B_MODES") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8_SET_DBG_COLOR_B_MODES$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8_SET_DBG_COLOR_B_MODES$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8_SET_DBG_COLOR_B_MODES") 
	synchronized protected native static int vpx_codec_control_VP8_SET_DBG_COLOR_B_MODES$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8_SET_DBG_DISPLAY_MV(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8.h:116</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8_SET_DBG_DISPLAY_MV(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8_SET_DBG_DISPLAY_MV(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8_SET_DBG_DISPLAY_MV(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8_SET_DBG_DISPLAY_MV(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8.h:116</i>
	 */
	@Name("vpx_codec_control_VP8_SET_DBG_DISPLAY_MV") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8_SET_DBG_DISPLAY_MV$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8_SET_DBG_DISPLAY_MV$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8_SET_DBG_DISPLAY_MV") 
	synchronized protected native static int vpx_codec_control_VP8_SET_DBG_DISPLAY_MV$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_iface_t* vpx_codec_vp8_cx()</code><br>
	 * <i>native declaration : vpx\vp8cx.h:32</i>
	 */
	synchronized public static Pointer<VpxLibrary.vpx_codec_iface > vpx_codec_vp8_cx() {
		return Pointer.pointerToAddress(vpx_codec_vp8_cx$2(), VpxLibrary.vpx_codec_iface.class);
	}
	@Ptr 
	@Name("vpx_codec_vp8_cx") 
	synchronized protected native static long vpx_codec_vp8_cx$2();
	/**
	 * These controls have been deprecated in favor of the flags parameter to<br>
	 * vpx_codec_encode(). See the definition of VP8_EFLAG_* above.<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_UPD_ENTROPY(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:274</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_UPD_ENTROPY(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_UPD_ENTROPY(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_UPD_ENTROPY(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_UPD_ENTROPY(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:274</i>
	 */
	@Name("vpx_codec_control_VP8E_UPD_ENTROPY") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_UPD_ENTROPY$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_UPD_ENTROPY$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_UPD_ENTROPY") 
	synchronized protected native static int vpx_codec_control_VP8E_UPD_ENTROPY$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_UPD_REFERENCE(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:275</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_UPD_REFERENCE(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_UPD_REFERENCE(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_UPD_REFERENCE(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_UPD_REFERENCE(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:275</i>
	 */
	@Name("vpx_codec_control_VP8E_UPD_REFERENCE") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_UPD_REFERENCE$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_UPD_REFERENCE$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_UPD_REFERENCE") 
	synchronized protected native static int vpx_codec_control_VP8E_UPD_REFERENCE$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_USE_REFERENCE(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:276</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_USE_REFERENCE(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_USE_REFERENCE(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_USE_REFERENCE(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_USE_REFERENCE(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:276</i>
	 */
	@Name("vpx_codec_control_VP8E_USE_REFERENCE") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_USE_REFERENCE$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_USE_REFERENCE$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_USE_REFERENCE") 
	synchronized protected native static int vpx_codec_control_VP8E_USE_REFERENCE$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_ROI_MAP(vpx_codec_ctx_t*, int, vpx_roi_map_t*)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:278</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_ROI_MAP(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, Pointer<vpx_roi_map_t > vpx_roi_map_tPtr1) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_ROI_MAP(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, Pointer.getPeer(vpx_roi_map_tPtr1)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_SET_ROI_MAP(@Ptr long vpx_codec_ctx_tPtr1, int int1, @Ptr long vpx_roi_map_tPtr1);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_ROI_MAP(vpx_codec_ctx_t*, int, vpx_roi_map_t*)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:278</i>
	 */
	@Name("vpx_codec_control_VP8E_SET_ROI_MAP") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_ROI_MAP$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, Pointer<vpx_roi_map_t > data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_ROI_MAP$2(Pointer.getPeer(ctx), ctrl_id, Pointer.getPeer(data)), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_SET_ROI_MAP") 
	synchronized protected native static int vpx_codec_control_VP8E_SET_ROI_MAP$2(@Ptr long ctx, int ctrl_id, @Ptr long data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_ACTIVEMAP(vpx_codec_ctx_t*, int, vpx_active_map_t*)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:279</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_ACTIVEMAP(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, Pointer<vpx_active_map_t > vpx_active_map_tPtr1) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_ACTIVEMAP(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, Pointer.getPeer(vpx_active_map_tPtr1)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_SET_ACTIVEMAP(@Ptr long vpx_codec_ctx_tPtr1, int int1, @Ptr long vpx_active_map_tPtr1);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_ACTIVEMAP(vpx_codec_ctx_t*, int, vpx_active_map_t*)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:279</i>
	 */
	@Name("vpx_codec_control_VP8E_SET_ACTIVEMAP") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_ACTIVEMAP$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, Pointer<vpx_active_map_t > data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_ACTIVEMAP$2(Pointer.getPeer(ctx), ctrl_id, Pointer.getPeer(data)), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_SET_ACTIVEMAP") 
	synchronized protected native static int vpx_codec_control_VP8E_SET_ACTIVEMAP$2(@Ptr long ctx, int ctrl_id, @Ptr long data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_SCALEMODE(vpx_codec_ctx_t*, int, vpx_scaling_mode_t*)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:280</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_SCALEMODE(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, Pointer<vpx_scaling_mode_t > vpx_scaling_mode_tPtr1) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_SCALEMODE(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, Pointer.getPeer(vpx_scaling_mode_tPtr1)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_SET_SCALEMODE(@Ptr long vpx_codec_ctx_tPtr1, int int1, @Ptr long vpx_scaling_mode_tPtr1);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_SCALEMODE(vpx_codec_ctx_t*, int, vpx_scaling_mode_t*)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:280</i>
	 */
	@Name("vpx_codec_control_VP8E_SET_SCALEMODE") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_SCALEMODE$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, Pointer<vpx_scaling_mode_t > data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_SCALEMODE$2(Pointer.getPeer(ctx), ctrl_id, Pointer.getPeer(data)), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_SET_SCALEMODE") 
	synchronized protected native static int vpx_codec_control_VP8E_SET_SCALEMODE$2(@Ptr long ctx, int ctrl_id, @Ptr long data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_CPUUSED(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:282</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_CPUUSED(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_CPUUSED(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_SET_CPUUSED(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_CPUUSED(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:282</i>
	 */
	@Name("vpx_codec_control_VP8E_SET_CPUUSED") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_CPUUSED$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_CPUUSED$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_SET_CPUUSED") 
	synchronized protected native static int vpx_codec_control_VP8E_SET_CPUUSED$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_ENABLEAUTOALTREF(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:283</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_ENABLEAUTOALTREF(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_ENABLEAUTOALTREF(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_SET_ENABLEAUTOALTREF(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_ENABLEAUTOALTREF(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:283</i>
	 */
	@Name("vpx_codec_control_VP8E_SET_ENABLEAUTOALTREF") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_ENABLEAUTOALTREF$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_ENABLEAUTOALTREF$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_SET_ENABLEAUTOALTREF") 
	synchronized protected native static int vpx_codec_control_VP8E_SET_ENABLEAUTOALTREF$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_NOISE_SENSITIVITY(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:284</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_NOISE_SENSITIVITY(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_NOISE_SENSITIVITY(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_SET_NOISE_SENSITIVITY(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_NOISE_SENSITIVITY(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:284</i>
	 */
	@Name("vpx_codec_control_VP8E_SET_NOISE_SENSITIVITY") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_NOISE_SENSITIVITY$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_NOISE_SENSITIVITY$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_SET_NOISE_SENSITIVITY") 
	synchronized protected native static int vpx_codec_control_VP8E_SET_NOISE_SENSITIVITY$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_SHARPNESS(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:285</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_SHARPNESS(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_SHARPNESS(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_SET_SHARPNESS(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_SHARPNESS(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:285</i>
	 */
	@Name("vpx_codec_control_VP8E_SET_SHARPNESS") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_SHARPNESS$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_SHARPNESS$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_SET_SHARPNESS") 
	synchronized protected native static int vpx_codec_control_VP8E_SET_SHARPNESS$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_STATIC_THRESHOLD(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:286</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_STATIC_THRESHOLD(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_STATIC_THRESHOLD(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_SET_STATIC_THRESHOLD(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_STATIC_THRESHOLD(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:286</i>
	 */
	@Name("vpx_codec_control_VP8E_SET_STATIC_THRESHOLD") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_STATIC_THRESHOLD$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_STATIC_THRESHOLD$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_SET_STATIC_THRESHOLD") 
	synchronized protected native static int vpx_codec_control_VP8E_SET_STATIC_THRESHOLD$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_TOKEN_PARTITIONS(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:287</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_TOKEN_PARTITIONS(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_TOKEN_PARTITIONS(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_SET_TOKEN_PARTITIONS(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * vp8e_token_partitions<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_TOKEN_PARTITIONS(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:287</i>
	 */
	@Name("vpx_codec_control_VP8E_SET_TOKEN_PARTITIONS") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_TOKEN_PARTITIONS$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_TOKEN_PARTITIONS$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_SET_TOKEN_PARTITIONS") 
	synchronized protected native static int vpx_codec_control_VP8E_SET_TOKEN_PARTITIONS$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_ARNR_MAXFRAMES(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:289</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_ARNR_MAXFRAMES(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_ARNR_MAXFRAMES(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_SET_ARNR_MAXFRAMES(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_ARNR_MAXFRAMES(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:289</i>
	 */
	@Name("vpx_codec_control_VP8E_SET_ARNR_MAXFRAMES") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_ARNR_MAXFRAMES$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_ARNR_MAXFRAMES$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_SET_ARNR_MAXFRAMES") 
	synchronized protected native static int vpx_codec_control_VP8E_SET_ARNR_MAXFRAMES$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_ARNR_STRENGTH(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:290</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_ARNR_STRENGTH(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_ARNR_STRENGTH(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_SET_ARNR_STRENGTH(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_ARNR_STRENGTH(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:290</i>
	 */
	@Name("vpx_codec_control_VP8E_SET_ARNR_STRENGTH") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_ARNR_STRENGTH$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_ARNR_STRENGTH$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_SET_ARNR_STRENGTH") 
	synchronized protected native static int vpx_codec_control_VP8E_SET_ARNR_STRENGTH$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_ARNR_TYPE(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:291</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_ARNR_TYPE(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_ARNR_TYPE(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_SET_ARNR_TYPE(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_ARNR_TYPE(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:291</i>
	 */
	@Name("vpx_codec_control_VP8E_SET_ARNR_TYPE") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_ARNR_TYPE$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_ARNR_TYPE$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_SET_ARNR_TYPE") 
	synchronized protected native static int vpx_codec_control_VP8E_SET_ARNR_TYPE$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_TUNING(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:292</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_TUNING(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_TUNING(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_SET_TUNING(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * vp8e_tuning<br>
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_TUNING(vpx_codec_ctx_t*, int, int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:292</i>
	 */
	@Name("vpx_codec_control_VP8E_SET_TUNING") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_TUNING$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_TUNING$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_SET_TUNING") 
	synchronized protected native static int vpx_codec_control_VP8E_SET_TUNING$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_CQ_LEVEL(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:293</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_CQ_LEVEL(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_CQ_LEVEL(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_SET_CQ_LEVEL(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_CQ_LEVEL(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:293</i>
	 */
	@Name("vpx_codec_control_VP8E_SET_CQ_LEVEL") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_CQ_LEVEL$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_CQ_LEVEL$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_SET_CQ_LEVEL") 
	synchronized protected native static int vpx_codec_control_VP8E_SET_CQ_LEVEL$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_GET_LAST_QUANTIZER(vpx_codec_ctx_t*, int, int*)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:295</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_GET_LAST_QUANTIZER(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, Pointer<Integer > intPtr1) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_GET_LAST_QUANTIZER(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, Pointer.getPeer(intPtr1)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_GET_LAST_QUANTIZER(@Ptr long vpx_codec_ctx_tPtr1, int int1, @Ptr long intPtr1);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_GET_LAST_QUANTIZER(vpx_codec_ctx_t*, int, int*)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:295</i>
	 */
	@Name("vpx_codec_control_VP8E_GET_LAST_QUANTIZER") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_GET_LAST_QUANTIZER$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, Pointer<Integer > data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_GET_LAST_QUANTIZER$2(Pointer.getPeer(ctx), ctrl_id, Pointer.getPeer(data)), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_GET_LAST_QUANTIZER") 
	synchronized protected native static int vpx_codec_control_VP8E_GET_LAST_QUANTIZER$2(@Ptr long ctx, int ctrl_id, @Ptr long data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64(vpx_codec_ctx_t*, int, int*)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:296</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, Pointer<Integer > intPtr1) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, Pointer.getPeer(intPtr1)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64(@Ptr long vpx_codec_ctx_tPtr1, int int1, @Ptr long intPtr1);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64(vpx_codec_ctx_t*, int, int*)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:296</i>
	 */
	@Name("vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, Pointer<Integer > data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64$2(Pointer.getPeer(ctx), ctrl_id, Pointer.getPeer(data)), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64") 
	synchronized protected native static int vpx_codec_control_VP8E_GET_LAST_QUANTIZER_64$2(@Ptr long ctx, int ctrl_id, @Ptr long data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCT(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:298</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCT(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, int int2) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCT(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, int2), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCT(@Ptr long vpx_codec_ctx_tPtr1, int int1, int int2);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCT(vpx_codec_ctx_t*, int, unsigned int)</code><br>
	 * <i>native declaration : vpx\vp8cx.h:298</i>
	 */
	@Name("vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCT") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCT$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, int data) {
		return FlagSet.fromValue(vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCT$2(Pointer.getPeer(ctx), ctrl_id, data), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCT") 
	synchronized protected native static int vpx_codec_control_VP8E_SET_MAX_INTRA_BITRATE_PCT$2(@Ptr long ctx, int ctrl_id, int data);
	/**
	 * Original signature : <code>vpx_codec_iface_t* vpx_codec_vp8_dx()</code><br>
	 * <i>native declaration : vpx\vp8dx.h:32</i>
	 */
	synchronized public static Pointer<VpxLibrary.vpx_codec_iface > vpx_codec_vp8_dx() {
		return Pointer.pointerToAddress(vpx_codec_vp8_dx$2(), VpxLibrary.vpx_codec_iface.class);
	}
	@Ptr 
	@Name("vpx_codec_vp8_dx") 
	synchronized protected native static long vpx_codec_vp8_dx$2();
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8D_GET_LAST_REF_UPDATES(vpx_codec_ctx_t*, int, int*)</code><br>
	 * <i>native declaration : vpx\vp8dx.h:72</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8D_GET_LAST_REF_UPDATES(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, Pointer<Integer > intPtr1) {
		return FlagSet.fromValue(vpx_codec_control_VP8D_GET_LAST_REF_UPDATES(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, Pointer.getPeer(intPtr1)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8D_GET_LAST_REF_UPDATES(@Ptr long vpx_codec_ctx_tPtr1, int int1, @Ptr long intPtr1);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8D_GET_LAST_REF_UPDATES(vpx_codec_ctx_t*, int, int*)</code><br>
	 * <i>native declaration : vpx\vp8dx.h:72</i>
	 */
	@Name("vpx_codec_control_VP8D_GET_LAST_REF_UPDATES") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8D_GET_LAST_REF_UPDATES$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, Pointer<Integer > data) {
		return FlagSet.fromValue(vpx_codec_control_VP8D_GET_LAST_REF_UPDATES$2(Pointer.getPeer(ctx), ctrl_id, Pointer.getPeer(data)), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8D_GET_LAST_REF_UPDATES") 
	synchronized protected native static int vpx_codec_control_VP8D_GET_LAST_REF_UPDATES$2(@Ptr long ctx, int ctrl_id, @Ptr long data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8D_GET_FRAME_CORRUPTED(vpx_codec_ctx_t*, int, int*)</code><br>
	 * <i>native declaration : vpx\vp8dx.h:73</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8D_GET_FRAME_CORRUPTED(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, Pointer<Integer > intPtr1) {
		return FlagSet.fromValue(vpx_codec_control_VP8D_GET_FRAME_CORRUPTED(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, Pointer.getPeer(intPtr1)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8D_GET_FRAME_CORRUPTED(@Ptr long vpx_codec_ctx_tPtr1, int int1, @Ptr long intPtr1);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8D_GET_FRAME_CORRUPTED(vpx_codec_ctx_t*, int, int*)</code><br>
	 * <i>native declaration : vpx\vp8dx.h:73</i>
	 */
	@Name("vpx_codec_control_VP8D_GET_FRAME_CORRUPTED") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8D_GET_FRAME_CORRUPTED$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, Pointer<Integer > data) {
		return FlagSet.fromValue(vpx_codec_control_VP8D_GET_FRAME_CORRUPTED$2(Pointer.getPeer(ctx), ctrl_id, Pointer.getPeer(data)), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8D_GET_FRAME_CORRUPTED") 
	synchronized protected native static int vpx_codec_control_VP8D_GET_FRAME_CORRUPTED$2(@Ptr long ctx, int ctrl_id, @Ptr long data);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8D_GET_LAST_REF_USED(vpx_codec_ctx_t*, int, int*)</code><br>
	 * <i>native declaration : vpx\vp8dx.h:74</i>
	 */
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8D_GET_LAST_REF_USED(Pointer<vpx_codec_ctx_t > vpx_codec_ctx_tPtr1, int int1, Pointer<Integer > intPtr1) {
		return FlagSet.fromValue(vpx_codec_control_VP8D_GET_LAST_REF_USED(Pointer.getPeer(vpx_codec_ctx_tPtr1), int1, Pointer.getPeer(intPtr1)), VpxLibrary.vpx_codec_err_t.class);
	}
	synchronized protected native static int vpx_codec_control_VP8D_GET_LAST_REF_USED(@Ptr long vpx_codec_ctx_tPtr1, int int1, @Ptr long intPtr1);
	/**
	 * Original signature : <code>vpx_codec_err_t vpx_codec_control_VP8D_GET_LAST_REF_USED(vpx_codec_ctx_t*, int, int*)</code><br>
	 * <i>native declaration : vpx\vp8dx.h:74</i>
	 */
	@Name("vpx_codec_control_VP8D_GET_LAST_REF_USED") 
	synchronized public static IntValuedEnum<VpxLibrary.vpx_codec_err_t > vpx_codec_control_VP8D_GET_LAST_REF_USED$2(Pointer<vpx_codec_ctx_t > ctx, int ctrl_id, Pointer<Integer > data) {
		return FlagSet.fromValue(vpx_codec_control_VP8D_GET_LAST_REF_USED$2(Pointer.getPeer(ctx), ctrl_id, Pointer.getPeer(data)), VpxLibrary.vpx_codec_err_t.class);
	}
	@Name("vpx_codec_control_VP8D_GET_LAST_REF_USED") 
	synchronized protected native static int vpx_codec_control_VP8D_GET_LAST_REF_USED$2(@Ptr long ctx, int ctrl_id, @Ptr long data);
	public static class vpx_codec_priv_t extends TypedPointer {
		public vpx_codec_priv_t(long address) {
			super(address);
		}
		public vpx_codec_priv_t(Pointer address) {
			super(address);
		}
	};
	public static class vpx_codec_iface_t extends TypedPointer {
		public vpx_codec_iface_t(long address) {
			super(address);
		}
		public vpx_codec_iface_t(Pointer address) {
			super(address);
		}
	};
	/// Undefined type
	/// Undefined type
	public static interface vpx_codec_priv {
		
	};
	/// Undefined type
	/// Undefined type
	public static interface vpx_codec_iface {
		
	};
}
