package vpx;
import org.bridj.IntValuedEnum;
import org.bridj.Pointer;
import org.bridj.StructObject;
import org.bridj.ann.Array;
import org.bridj.ann.Field;
import org.bridj.ann.Library;
import vpx.VpxLibrary.vpx_enc_pass;
import vpx.VpxLibrary.vpx_kf_mode;
import vpx.VpxLibrary.vpx_rc_mode;
/**
 * <i>native declaration : vpx\vpx_encoder.h</i><br>
 * This file was autogenerated by <a href="http://jnaerator.googlecode.com/">JNAerator</a>,<br>
 * a tool written by <a href="http://ochafik.com/">Olivier Chafik</a> that <a href="http://code.google.com/p/jnaerator/wiki/CreditsAndLicense">uses a few opensource projects.</a>.<br>
 * For help, please visit <a href="http://nativelibs4java.googlecode.com/">NativeLibs4Java</a> or <a href="http://bridj.googlecode.com/">BridJ</a> .
 */
@Library("vpx") 
public class vpx_codec_enc_cfg_t extends StructObject {
	public vpx_codec_enc_cfg_t() {
		super();
	}
	/**
	 * \brief Algorithm specific "usage" value<br>
	 * * Algorithms may define multiple values for usage, which may convey the<br>
	 * intent of how the application intends to use the stream. If this value<br>
	 * is non-zero, consult the documentation for the codec to determine its<br>
	 * meaning.
	 */
	@Field(0) 
	public int g_usage() {
		return this.io.getIntField(this, 0);
	}
	/**
	 * \brief Algorithm specific "usage" value<br>
	 * * Algorithms may define multiple values for usage, which may convey the<br>
	 * intent of how the application intends to use the stream. If this value<br>
	 * is non-zero, consult the documentation for the codec to determine its<br>
	 * meaning.
	 */
	@Field(0) 
	public vpx_codec_enc_cfg_t g_usage(int g_usage) {
		this.io.setIntField(this, 0, g_usage);
		return this;
	}
	/**
	 * \brief Maximum number of threads to use<br>
	 * * For multi-threaded implementations, use no more than this number of<br>
	 * threads. The codec may use fewer threads than allowed. The value<br>
	 * 0 is equivalent to the value 1.
	 */
	@Field(1) 
	public int g_threads() {
		return this.io.getIntField(this, 1);
	}
	/**
	 * \brief Maximum number of threads to use<br>
	 * * For multi-threaded implementations, use no more than this number of<br>
	 * threads. The codec may use fewer threads than allowed. The value<br>
	 * 0 is equivalent to the value 1.
	 */
	@Field(1) 
	public vpx_codec_enc_cfg_t g_threads(int g_threads) {
		this.io.setIntField(this, 1, g_threads);
		return this;
	}
	/**
	 * \brief Bitstream profile to use<br>
	 * * Some codecs support a notion of multiple bitstream profiles. Typically<br>
	 * this maps to a set of features that are turned on or off. Often the<br>
	 * profile to use is determined by the features of the intended decoder.<br>
	 * Consult the documentation for the codec to determine the valid values<br>
	 * for this parameter, or set to zero for a sane default.<br>
	 * < profile of bitstream to use
	 */
	@Field(2) 
	public int g_profile() {
		return this.io.getIntField(this, 2);
	}
	/**
	 * \brief Bitstream profile to use<br>
	 * * Some codecs support a notion of multiple bitstream profiles. Typically<br>
	 * this maps to a set of features that are turned on or off. Often the<br>
	 * profile to use is determined by the features of the intended decoder.<br>
	 * Consult the documentation for the codec to determine the valid values<br>
	 * for this parameter, or set to zero for a sane default.<br>
	 * < profile of bitstream to use
	 */
	@Field(2) 
	public vpx_codec_enc_cfg_t g_profile(int g_profile) {
		this.io.setIntField(this, 2, g_profile);
		return this;
	}
	/**
	 * \brief Width of the frame<br>
	 * * This value identifies the presentation resolution of the frame,<br>
	 * in pixels. Note that the frames passed as input to the encoder must<br>
	 * have this resolution. Frames will be presented by the decoder in this<br>
	 * resolution, independent of any spatial resampling the encoder may do.
	 */
	@Field(3) 
	public int g_w() {
		return this.io.getIntField(this, 3);
	}
	/**
	 * \brief Width of the frame<br>
	 * * This value identifies the presentation resolution of the frame,<br>
	 * in pixels. Note that the frames passed as input to the encoder must<br>
	 * have this resolution. Frames will be presented by the decoder in this<br>
	 * resolution, independent of any spatial resampling the encoder may do.
	 */
	@Field(3) 
	public vpx_codec_enc_cfg_t g_w(int g_w) {
		this.io.setIntField(this, 3, g_w);
		return this;
	}
	/**
	 * \brief Height of the frame<br>
	 * * This value identifies the presentation resolution of the frame,<br>
	 * in pixels. Note that the frames passed as input to the encoder must<br>
	 * have this resolution. Frames will be presented by the decoder in this<br>
	 * resolution, independent of any spatial resampling the encoder may do.
	 */
	@Field(4) 
	public int g_h() {
		return this.io.getIntField(this, 4);
	}
	/**
	 * \brief Height of the frame<br>
	 * * This value identifies the presentation resolution of the frame,<br>
	 * in pixels. Note that the frames passed as input to the encoder must<br>
	 * have this resolution. Frames will be presented by the decoder in this<br>
	 * resolution, independent of any spatial resampling the encoder may do.
	 */
	@Field(4) 
	public vpx_codec_enc_cfg_t g_h(int g_h) {
		this.io.setIntField(this, 4, g_h);
		return this;
	}
	/**
	 * \brief Stream timebase units<br>
	 * * Indicates the smallest interval of time, in seconds, used by the stream.<br>
	 * For fixed frame rate material, or variable frame rate material where<br>
	 * frames are timed at a multiple of a given clock (ex: video capture),<br>
	 * the \ref RECOMMENDED method is to set the timebase to the reciprocal<br>
	 * of the frame rate (ex: 1001/30000 for 29.970 Hz NTSC). This allows the<br>
	 * pts to correspond to the frame number, which can be handy. For<br>
	 * re-encoding video from containers with absolute time timestamps, the<br>
	 * \ref RECOMMENDED method is to set the timebase to that of the parent<br>
	 * container or multimedia framework (ex: 1/1000 for ms, as in FLV).<br>
	 * C type : vpx_rational
	 */
	@Field(5) 
	public vpx_rational_t g_timebase() {
		return this.io.getNativeObjectField(this, 5);
	}
	/**
	 * \brief Stream timebase units<br>
	 * * Indicates the smallest interval of time, in seconds, used by the stream.<br>
	 * For fixed frame rate material, or variable frame rate material where<br>
	 * frames are timed at a multiple of a given clock (ex: video capture),<br>
	 * the \ref RECOMMENDED method is to set the timebase to the reciprocal<br>
	 * of the frame rate (ex: 1001/30000 for 29.970 Hz NTSC). This allows the<br>
	 * pts to correspond to the frame number, which can be handy. For<br>
	 * re-encoding video from containers with absolute time timestamps, the<br>
	 * \ref RECOMMENDED method is to set the timebase to that of the parent<br>
	 * container or multimedia framework (ex: 1/1000 for ms, as in FLV).<br>
	 * C type : vpx_rational
	 */
	@Field(5) 
	public vpx_codec_enc_cfg_t g_timebase(vpx_rational_t g_timebase) {
		this.io.setNativeObjectField(this, 5, g_timebase);
		return this;
	}
	/**
	 * \brief Enable error resilient modes.<br>
	 * * The error resilient bitfield indicates to the encoder which features<br>
	 * it should enable to take measures for streaming over lossy or noisy<br>
	 * links.<br>
	 * C type : vpx_codec_er_flags_t
	 */
	@Field(6) 
	public int g_error_resilient() {
		return this.io.getIntField(this, 6);
	}
	/**
	 * \brief Enable error resilient modes.<br>
	 * * The error resilient bitfield indicates to the encoder which features<br>
	 * it should enable to take measures for streaming over lossy or noisy<br>
	 * links.<br>
	 * C type : vpx_codec_er_flags_t
	 */
	@Field(6) 
	public vpx_codec_enc_cfg_t g_error_resilient(int g_error_resilient) {
		this.io.setIntField(this, 6, g_error_resilient);
		return this;
	}
	/**
	 * \brief Multi-pass Encoding Mode<br>
	 * * This value should be set to the current phase for multi-pass encoding.<br>
	 * For single pass, set to #VPX_RC_ONE_PASS.<br>
	 * C type : vpx_enc_pass
	 */
	@Field(7) 
	public IntValuedEnum<vpx_enc_pass > g_pass() {
		return this.io.getEnumField(this, 7);
	}
	/**
	 * \brief Multi-pass Encoding Mode<br>
	 * * This value should be set to the current phase for multi-pass encoding.<br>
	 * For single pass, set to #VPX_RC_ONE_PASS.<br>
	 * C type : vpx_enc_pass
	 */
	@Field(7) 
	public vpx_codec_enc_cfg_t g_pass(IntValuedEnum<vpx_enc_pass > g_pass) {
		this.io.setEnumField(this, 7, g_pass);
		return this;
	}
	/**
	 * \brief Allow lagged encoding<br>
	 * * If set, this value allows the encoder to consume a number of input<br>
	 * frames before producing output frames. This allows the encoder to<br>
	 * base decisions for the current frame on future frames. This does<br>
	 * increase the latency of the encoding pipeline, so it is not appropriate<br>
	 * in all situations (ex: realtime encoding).<br>
	 * * Note that this is a maximum value -- the encoder may produce frames<br>
	 * sooner than the given limit. Set this value to 0 to disable this<br>
	 * feature.
	 */
	@Field(8) 
	public int g_lag_in_frames() {
		return this.io.getIntField(this, 8);
	}
	/**
	 * \brief Allow lagged encoding<br>
	 * * If set, this value allows the encoder to consume a number of input<br>
	 * frames before producing output frames. This allows the encoder to<br>
	 * base decisions for the current frame on future frames. This does<br>
	 * increase the latency of the encoding pipeline, so it is not appropriate<br>
	 * in all situations (ex: realtime encoding).<br>
	 * * Note that this is a maximum value -- the encoder may produce frames<br>
	 * sooner than the given limit. Set this value to 0 to disable this<br>
	 * feature.
	 */
	@Field(8) 
	public vpx_codec_enc_cfg_t g_lag_in_frames(int g_lag_in_frames) {
		this.io.setIntField(this, 8, g_lag_in_frames);
		return this;
	}
	/**
	 * \brief Temporal resampling configuration, if supported by the codec.<br>
	 * * Temporal resampling allows the codec to "drop" frames as a strategy to<br>
	 * meet its target data rate. This can cause temporal discontinuities in<br>
	 * the encoded video, which may appear as stuttering during playback. This<br>
	 * trade-off is often acceptable, but for many applications is not. It can<br>
	 * be disabled in these cases.<br>
	 * * Note that not all codecs support this feature. All vpx VPx codecs do.<br>
	 * For other codecs, consult the documentation for that algorithm.<br>
	 * * This threshold is described as a percentage of the target data buffer.<br>
	 * When the data buffer falls below this percentage of fullness, a<br>
	 * dropped frame is indicated. Set the threshold to zero (0) to disable<br>
	 * this feature.
	 */
	@Field(9) 
	public int rc_dropframe_thresh() {
		return this.io.getIntField(this, 9);
	}
	/**
	 * \brief Temporal resampling configuration, if supported by the codec.<br>
	 * * Temporal resampling allows the codec to "drop" frames as a strategy to<br>
	 * meet its target data rate. This can cause temporal discontinuities in<br>
	 * the encoded video, which may appear as stuttering during playback. This<br>
	 * trade-off is often acceptable, but for many applications is not. It can<br>
	 * be disabled in these cases.<br>
	 * * Note that not all codecs support this feature. All vpx VPx codecs do.<br>
	 * For other codecs, consult the documentation for that algorithm.<br>
	 * * This threshold is described as a percentage of the target data buffer.<br>
	 * When the data buffer falls below this percentage of fullness, a<br>
	 * dropped frame is indicated. Set the threshold to zero (0) to disable<br>
	 * this feature.
	 */
	@Field(9) 
	public vpx_codec_enc_cfg_t rc_dropframe_thresh(int rc_dropframe_thresh) {
		this.io.setIntField(this, 9, rc_dropframe_thresh);
		return this;
	}
	/**
	 * \brief Enable/disable spatial resampling, if supported by the codec.<br>
	 * * Spatial resampling allows the codec to compress a lower resolution<br>
	 * version of the frame, which is then upscaled by the encoder to the<br>
	 * correct presentation resolution. This increases visual quality at<br>
	 * low data rates, at the expense of CPU time on the encoder/decoder.
	 */
	@Field(10) 
	public int rc_resize_allowed() {
		return this.io.getIntField(this, 10);
	}
	/**
	 * \brief Enable/disable spatial resampling, if supported by the codec.<br>
	 * * Spatial resampling allows the codec to compress a lower resolution<br>
	 * version of the frame, which is then upscaled by the encoder to the<br>
	 * correct presentation resolution. This increases visual quality at<br>
	 * low data rates, at the expense of CPU time on the encoder/decoder.
	 */
	@Field(10) 
	public vpx_codec_enc_cfg_t rc_resize_allowed(int rc_resize_allowed) {
		this.io.setIntField(this, 10, rc_resize_allowed);
		return this;
	}
	/**
	 * \brief Spatial resampling up watermark.<br>
	 * * This threshold is described as a percentage of the target data buffer.<br>
	 * When the data buffer rises above this percentage of fullness, the<br>
	 * encoder will step up to a higher resolution version of the frame.
	 */
	@Field(11) 
	public int rc_resize_up_thresh() {
		return this.io.getIntField(this, 11);
	}
	/**
	 * \brief Spatial resampling up watermark.<br>
	 * * This threshold is described as a percentage of the target data buffer.<br>
	 * When the data buffer rises above this percentage of fullness, the<br>
	 * encoder will step up to a higher resolution version of the frame.
	 */
	@Field(11) 
	public vpx_codec_enc_cfg_t rc_resize_up_thresh(int rc_resize_up_thresh) {
		this.io.setIntField(this, 11, rc_resize_up_thresh);
		return this;
	}
	/**
	 * \brief Spatial resampling down watermark.<br>
	 * * This threshold is described as a percentage of the target data buffer.<br>
	 * When the data buffer falls below this percentage of fullness, the<br>
	 * encoder will step down to a lower resolution version of the frame.
	 */
	@Field(12) 
	public int rc_resize_down_thresh() {
		return this.io.getIntField(this, 12);
	}
	/**
	 * \brief Spatial resampling down watermark.<br>
	 * * This threshold is described as a percentage of the target data buffer.<br>
	 * When the data buffer falls below this percentage of fullness, the<br>
	 * encoder will step down to a lower resolution version of the frame.
	 */
	@Field(12) 
	public vpx_codec_enc_cfg_t rc_resize_down_thresh(int rc_resize_down_thresh) {
		this.io.setIntField(this, 12, rc_resize_down_thresh);
		return this;
	}
	/**
	 * \brief Rate control algorithm to use.<br>
	 * * Indicates whether the end usage of this stream is to be streamed over<br>
	 * a bandwidth constrained link, indicating that Constant Bit Rate (CBR)<br>
	 * mode should be used, or whether it will be played back on a high<br>
	 * bandwidth link, as from a local disk, where higher variations in<br>
	 * bitrate are acceptable.<br>
	 * C type : vpx_rc_mode
	 */
	@Field(13) 
	public IntValuedEnum<vpx_rc_mode > rc_end_usage() {
		return this.io.getEnumField(this, 13);
	}
	/**
	 * \brief Rate control algorithm to use.<br>
	 * * Indicates whether the end usage of this stream is to be streamed over<br>
	 * a bandwidth constrained link, indicating that Constant Bit Rate (CBR)<br>
	 * mode should be used, or whether it will be played back on a high<br>
	 * bandwidth link, as from a local disk, where higher variations in<br>
	 * bitrate are acceptable.<br>
	 * C type : vpx_rc_mode
	 */
	@Field(13) 
	public vpx_codec_enc_cfg_t rc_end_usage(IntValuedEnum<vpx_rc_mode > rc_end_usage) {
		this.io.setEnumField(this, 13, rc_end_usage);
		return this;
	}
	/**
	 * \brief Two-pass stats buffer.<br>
	 * * A buffer containing all of the stats packets produced in the first<br>
	 * pass, concatenated.<br>
	 * C type : vpx_fixed_buf
	 */
	@Field(14) 
	public vpx_fixed_buf_t rc_twopass_stats_in() {
		return this.io.getNativeObjectField(this, 14);
	}
	/**
	 * \brief Two-pass stats buffer.<br>
	 * * A buffer containing all of the stats packets produced in the first<br>
	 * pass, concatenated.<br>
	 * C type : vpx_fixed_buf
	 */
	@Field(14) 
	public vpx_codec_enc_cfg_t rc_twopass_stats_in(vpx_fixed_buf_t rc_twopass_stats_in) {
		this.io.setNativeObjectField(this, 14, rc_twopass_stats_in);
		return this;
	}
	/**
	 * \brief Target data rate<br>
	 * * Target bandwidth to use for this stream, in kilobits per second.
	 */
	@Field(15) 
	public int rc_target_bitrate() {
		return this.io.getIntField(this, 15);
	}
	/**
	 * \brief Target data rate<br>
	 * * Target bandwidth to use for this stream, in kilobits per second.
	 */
	@Field(15) 
	public vpx_codec_enc_cfg_t rc_target_bitrate(int rc_target_bitrate) {
		this.io.setIntField(this, 15, rc_target_bitrate);
		return this;
	}
	/**
	 * \brief Minimum (Best Quality) Quantizer<br>
	 * * The quantizer is the most direct control over the quality of the<br>
	 * encoded image. The range of valid values for the quantizer is codec<br>
	 * specific. Consult the documentation for the codec to determine the<br>
	 * values to use. To determine the range programmatically, call<br>
	 * vpx_codec_enc_config_default() with a usage value of 0.
	 */
	@Field(16) 
	public int rc_min_quantizer() {
		return this.io.getIntField(this, 16);
	}
	/**
	 * \brief Minimum (Best Quality) Quantizer<br>
	 * * The quantizer is the most direct control over the quality of the<br>
	 * encoded image. The range of valid values for the quantizer is codec<br>
	 * specific. Consult the documentation for the codec to determine the<br>
	 * values to use. To determine the range programmatically, call<br>
	 * vpx_codec_enc_config_default() with a usage value of 0.
	 */
	@Field(16) 
	public vpx_codec_enc_cfg_t rc_min_quantizer(int rc_min_quantizer) {
		this.io.setIntField(this, 16, rc_min_quantizer);
		return this;
	}
	/**
	 * \brief Maximum (Worst Quality) Quantizer<br>
	 * * The quantizer is the most direct control over the quality of the<br>
	 * encoded image. The range of valid values for the quantizer is codec<br>
	 * specific. Consult the documentation for the codec to determine the<br>
	 * values to use. To determine the range programmatically, call<br>
	 * vpx_codec_enc_config_default() with a usage value of 0.
	 */
	@Field(17) 
	public int rc_max_quantizer() {
		return this.io.getIntField(this, 17);
	}
	/**
	 * \brief Maximum (Worst Quality) Quantizer<br>
	 * * The quantizer is the most direct control over the quality of the<br>
	 * encoded image. The range of valid values for the quantizer is codec<br>
	 * specific. Consult the documentation for the codec to determine the<br>
	 * values to use. To determine the range programmatically, call<br>
	 * vpx_codec_enc_config_default() with a usage value of 0.
	 */
	@Field(17) 
	public vpx_codec_enc_cfg_t rc_max_quantizer(int rc_max_quantizer) {
		this.io.setIntField(this, 17, rc_max_quantizer);
		return this;
	}
	/**
	 * \brief Rate control adaptation undershoot control<br>
	 * * This value, expressed as a percentage of the target bitrate,<br>
	 * controls the maximum allowed adaptation speed of the codec.<br>
	 * This factor controls the maximum amount of bits that can<br>
	 * be subtracted from the target bitrate in order to compensate<br>
	 * for prior overshoot.<br>
	 * * Valid values in the range 0-1000.
	 */
	@Field(18) 
	public int rc_undershoot_pct() {
		return this.io.getIntField(this, 18);
	}
	/**
	 * \brief Rate control adaptation undershoot control<br>
	 * * This value, expressed as a percentage of the target bitrate,<br>
	 * controls the maximum allowed adaptation speed of the codec.<br>
	 * This factor controls the maximum amount of bits that can<br>
	 * be subtracted from the target bitrate in order to compensate<br>
	 * for prior overshoot.<br>
	 * * Valid values in the range 0-1000.
	 */
	@Field(18) 
	public vpx_codec_enc_cfg_t rc_undershoot_pct(int rc_undershoot_pct) {
		this.io.setIntField(this, 18, rc_undershoot_pct);
		return this;
	}
	/**
	 * \brief Rate control adaptation overshoot control<br>
	 * * This value, expressed as a percentage of the target bitrate,<br>
	 * controls the maximum allowed adaptation speed of the codec.<br>
	 * This factor controls the maximum amount of bits that can<br>
	 * be added to the target bitrate in order to compensate for<br>
	 * prior undershoot.<br>
	 * * Valid values in the range 0-1000.
	 */
	@Field(19) 
	public int rc_overshoot_pct() {
		return this.io.getIntField(this, 19);
	}
	/**
	 * \brief Rate control adaptation overshoot control<br>
	 * * This value, expressed as a percentage of the target bitrate,<br>
	 * controls the maximum allowed adaptation speed of the codec.<br>
	 * This factor controls the maximum amount of bits that can<br>
	 * be added to the target bitrate in order to compensate for<br>
	 * prior undershoot.<br>
	 * * Valid values in the range 0-1000.
	 */
	@Field(19) 
	public vpx_codec_enc_cfg_t rc_overshoot_pct(int rc_overshoot_pct) {
		this.io.setIntField(this, 19, rc_overshoot_pct);
		return this;
	}
	/**
	 * \brief Decoder Buffer Size<br>
	 * * This value indicates the amount of data that may be buffered by the<br>
	 * decoding application. Note that this value is expressed in units of<br>
	 * time (milliseconds). For example, a value of 5000 indicates that the<br>
	 * client will buffer (at least) 5000ms worth of encoded data. Use the<br>
	 * target bitrate (#rc_target_bitrate) to convert to bits/bytes, if<br>
	 * necessary.
	 */
	@Field(20) 
	public int rc_buf_sz() {
		return this.io.getIntField(this, 20);
	}
	/**
	 * \brief Decoder Buffer Size<br>
	 * * This value indicates the amount of data that may be buffered by the<br>
	 * decoding application. Note that this value is expressed in units of<br>
	 * time (milliseconds). For example, a value of 5000 indicates that the<br>
	 * client will buffer (at least) 5000ms worth of encoded data. Use the<br>
	 * target bitrate (#rc_target_bitrate) to convert to bits/bytes, if<br>
	 * necessary.
	 */
	@Field(20) 
	public vpx_codec_enc_cfg_t rc_buf_sz(int rc_buf_sz) {
		this.io.setIntField(this, 20, rc_buf_sz);
		return this;
	}
	/**
	 * \brief Decoder Buffer Initial Size<br>
	 * * This value indicates the amount of data that will be buffered by the<br>
	 * decoding application prior to beginning playback. This value is<br>
	 * expressed in units of time (milliseconds). Use the target bitrate<br>
	 * (#rc_target_bitrate) to convert to bits/bytes, if necessary.
	 */
	@Field(21) 
	public int rc_buf_initial_sz() {
		return this.io.getIntField(this, 21);
	}
	/**
	 * \brief Decoder Buffer Initial Size<br>
	 * * This value indicates the amount of data that will be buffered by the<br>
	 * decoding application prior to beginning playback. This value is<br>
	 * expressed in units of time (milliseconds). Use the target bitrate<br>
	 * (#rc_target_bitrate) to convert to bits/bytes, if necessary.
	 */
	@Field(21) 
	public vpx_codec_enc_cfg_t rc_buf_initial_sz(int rc_buf_initial_sz) {
		this.io.setIntField(this, 21, rc_buf_initial_sz);
		return this;
	}
	/**
	 * \brief Decoder Buffer Optimal Size<br>
	 * * This value indicates the amount of data that the encoder should try<br>
	 * to maintain in the decoder's buffer. This value is expressed in units<br>
	 * of time (milliseconds). Use the target bitrate (#rc_target_bitrate)<br>
	 * to convert to bits/bytes, if necessary.
	 */
	@Field(22) 
	public int rc_buf_optimal_sz() {
		return this.io.getIntField(this, 22);
	}
	/**
	 * \brief Decoder Buffer Optimal Size<br>
	 * * This value indicates the amount of data that the encoder should try<br>
	 * to maintain in the decoder's buffer. This value is expressed in units<br>
	 * of time (milliseconds). Use the target bitrate (#rc_target_bitrate)<br>
	 * to convert to bits/bytes, if necessary.
	 */
	@Field(22) 
	public vpx_codec_enc_cfg_t rc_buf_optimal_sz(int rc_buf_optimal_sz) {
		this.io.setIntField(this, 22, rc_buf_optimal_sz);
		return this;
	}
	/**
	 * \brief Two-pass mode CBR/VBR bias<br>
	 * * Bias, expressed on a scale of 0 to 100, for determining target size<br>
	 * for the current frame. The value 0 indicates the optimal CBR mode<br>
	 * value should be used. The value 100 indicates the optimal VBR mode<br>
	 * value should be used. Values in between indicate which way the<br>
	 * encoder should "lean."<br>
	 * < RC mode bias between CBR and VBR(0-100: 0->CBR, 100->VBR)
	 */
	@Field(23) 
	public int rc_2pass_vbr_bias_pct() {
		return this.io.getIntField(this, 23);
	}
	/**
	 * \brief Two-pass mode CBR/VBR bias<br>
	 * * Bias, expressed on a scale of 0 to 100, for determining target size<br>
	 * for the current frame. The value 0 indicates the optimal CBR mode<br>
	 * value should be used. The value 100 indicates the optimal VBR mode<br>
	 * value should be used. Values in between indicate which way the<br>
	 * encoder should "lean."<br>
	 * < RC mode bias between CBR and VBR(0-100: 0->CBR, 100->VBR)
	 */
	@Field(23) 
	public vpx_codec_enc_cfg_t rc_2pass_vbr_bias_pct(int rc_2pass_vbr_bias_pct) {
		this.io.setIntField(this, 23, rc_2pass_vbr_bias_pct);
		return this;
	}
	/**
	 * \brief Two-pass mode per-GOP minimum bitrate<br>
	 * * This value, expressed as a percentage of the target bitrate, indicates<br>
	 * the minimum bitrate to be used for a single GOP (aka "section")
	 */
	@Field(24) 
	public int rc_2pass_vbr_minsection_pct() {
		return this.io.getIntField(this, 24);
	}
	/**
	 * \brief Two-pass mode per-GOP minimum bitrate<br>
	 * * This value, expressed as a percentage of the target bitrate, indicates<br>
	 * the minimum bitrate to be used for a single GOP (aka "section")
	 */
	@Field(24) 
	public vpx_codec_enc_cfg_t rc_2pass_vbr_minsection_pct(int rc_2pass_vbr_minsection_pct) {
		this.io.setIntField(this, 24, rc_2pass_vbr_minsection_pct);
		return this;
	}
	/**
	 * \brief Two-pass mode per-GOP maximum bitrate<br>
	 * * This value, expressed as a percentage of the target bitrate, indicates<br>
	 * the maximum bitrate to be used for a single GOP (aka "section")
	 */
	@Field(25) 
	public int rc_2pass_vbr_maxsection_pct() {
		return this.io.getIntField(this, 25);
	}
	/**
	 * \brief Two-pass mode per-GOP maximum bitrate<br>
	 * * This value, expressed as a percentage of the target bitrate, indicates<br>
	 * the maximum bitrate to be used for a single GOP (aka "section")
	 */
	@Field(25) 
	public vpx_codec_enc_cfg_t rc_2pass_vbr_maxsection_pct(int rc_2pass_vbr_maxsection_pct) {
		this.io.setIntField(this, 25, rc_2pass_vbr_maxsection_pct);
		return this;
	}
	/**
	 * \brief Keyframe placement mode<br>
	 * * This value indicates whether the encoder should place keyframes at a<br>
	 * fixed interval, or determine the optimal placement automatically<br>
	 * (as governed by the #kf_min_dist and #kf_max_dist parameters)<br>
	 * C type : vpx_kf_mode
	 */
	@Field(26) 
	public IntValuedEnum<vpx_kf_mode > kf_mode() {
		return this.io.getEnumField(this, 26);
	}
	/**
	 * \brief Keyframe placement mode<br>
	 * * This value indicates whether the encoder should place keyframes at a<br>
	 * fixed interval, or determine the optimal placement automatically<br>
	 * (as governed by the #kf_min_dist and #kf_max_dist parameters)<br>
	 * C type : vpx_kf_mode
	 */
	@Field(26) 
	public vpx_codec_enc_cfg_t kf_mode(IntValuedEnum<vpx_kf_mode > kf_mode) {
		this.io.setEnumField(this, 26, kf_mode);
		return this;
	}
	/**
	 * \brief Keyframe minimum interval<br>
	 * * This value, expressed as a number of frames, prevents the encoder from<br>
	 * placing a keyframe nearer than kf_min_dist to the previous keyframe. At<br>
	 * least kf_min_dist frames non-keyframes will be coded before the next<br>
	 * keyframe. Set kf_min_dist equal to kf_max_dist for a fixed interval.
	 */
	@Field(27) 
	public int kf_min_dist() {
		return this.io.getIntField(this, 27);
	}
	/**
	 * \brief Keyframe minimum interval<br>
	 * * This value, expressed as a number of frames, prevents the encoder from<br>
	 * placing a keyframe nearer than kf_min_dist to the previous keyframe. At<br>
	 * least kf_min_dist frames non-keyframes will be coded before the next<br>
	 * keyframe. Set kf_min_dist equal to kf_max_dist for a fixed interval.
	 */
	@Field(27) 
	public vpx_codec_enc_cfg_t kf_min_dist(int kf_min_dist) {
		this.io.setIntField(this, 27, kf_min_dist);
		return this;
	}
	/**
	 * \brief Keyframe maximum interval<br>
	 * * This value, expressed as a number of frames, forces the encoder to code<br>
	 * a keyframe if one has not been coded in the last kf_max_dist frames.<br>
	 * A value of 0 implies all frames will be keyframes. Set kf_min_dist<br>
	 * equal to kf_max_dist for a fixed interval.
	 */
	@Field(28) 
	public int kf_max_dist() {
		return this.io.getIntField(this, 28);
	}
	/**
	 * \brief Keyframe maximum interval<br>
	 * * This value, expressed as a number of frames, forces the encoder to code<br>
	 * a keyframe if one has not been coded in the last kf_max_dist frames.<br>
	 * A value of 0 implies all frames will be keyframes. Set kf_min_dist<br>
	 * equal to kf_max_dist for a fixed interval.
	 */
	@Field(28) 
	public vpx_codec_enc_cfg_t kf_max_dist(int kf_max_dist) {
		this.io.setIntField(this, 28, kf_max_dist);
		return this;
	}
	/**
	 * \brief Number of coding layers<br>
	 * * This value specifies the number of coding layers to be used.
	 */
	@Field(29) 
	public int ts_number_layers() {
		return this.io.getIntField(this, 29);
	}
	/**
	 * \brief Number of coding layers<br>
	 * * This value specifies the number of coding layers to be used.
	 */
	@Field(29) 
	public vpx_codec_enc_cfg_t ts_number_layers(int ts_number_layers) {
		this.io.setIntField(this, 29, ts_number_layers);
		return this;
	}
	/**
	 * \brief Target bitrate for each layer<br>
	 * * These values specify the target coding bitrate for each coding layer.<br>
	 * C type : unsigned int[5]
	 */
	@Array({5}) 
	@Field(30) 
	public Pointer<Integer > ts_target_bitrate() {
		return this.io.getPointerField(this, 30);
	}
	/**
	 * \brief Frame rate decimation factor for each layer<br>
	 * * These values specify the frame rate decimation factors to apply<br>
	 * to each layer.<br>
	 * C type : unsigned int[5]
	 */
	@Array({5}) 
	@Field(31) 
	public Pointer<Integer > ts_rate_decimator() {
		return this.io.getPointerField(this, 31);
	}
	/**
	 * \brief Length of the sequence defining frame layer membership<br>
	 * * This value specifies the length of the sequence that defines the<br>
	 * membership of frames to layers. For example, if ts_periodicity=8 then<br>
	 * frames are assigned to coding layers with a repeated sequence of<br>
	 * length 8.
	 */
	@Field(32) 
	public int ts_periodicity() {
		return this.io.getIntField(this, 32);
	}
	/**
	 * \brief Length of the sequence defining frame layer membership<br>
	 * * This value specifies the length of the sequence that defines the<br>
	 * membership of frames to layers. For example, if ts_periodicity=8 then<br>
	 * frames are assigned to coding layers with a repeated sequence of<br>
	 * length 8.
	 */
	@Field(32) 
	public vpx_codec_enc_cfg_t ts_periodicity(int ts_periodicity) {
		this.io.setIntField(this, 32, ts_periodicity);
		return this;
	}
	/**
	 * \brief Template defining the membership of frames to coding layers<br>
	 * * This array defines the membership of frames to coding layers. For a<br>
	 * 2-layer encoding that assigns even numbered frames to one layer (0)<br>
	 * and odd numbered frames to a second layer (1) with ts_periodicity=8,<br>
	 * then ts_layer_id = (0,1,0,1,0,1,0,1).<br>
	 * C type : unsigned int[16]
	 */
	@Array({16}) 
	@Field(33) 
	public Pointer<Integer > ts_layer_id() {
		return this.io.getPointerField(this, 33);
	}
	public vpx_codec_enc_cfg_t(Pointer pointer) {
		super(pointer);
	}
}
